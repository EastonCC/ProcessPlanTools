<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Formula Editor - ProcessPlanTools</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; 
        background: #191919; 
        color: #e0e0e0;
        min-height: 100vh; 
    }

    /* Header */
    .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 24px;
        border-bottom: 1px solid #333;
    }

    .header-left {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .status-dot {
        width: 10px;
        height: 10px;
        background: #3b82f6;
        border-radius: 50%;
    }

    .header-title {
        font-size: 15px;
        font-weight: 500;
        color: #e0e0e0;
    }

    .toggle-sidebar-btn {
        background: #3b82f6;
        border: none;
        color: white;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .toggle-sidebar-btn:hover {
        background: #2563eb;
    }

    /* Main Content */
    .main-content {
        max-width: 1100px;
        margin: 0 auto;
        padding: 32px 24px;
    }

    /* Editor Card */
    .editor-card {
        background: #232323;
        border: 1px solid #333;
        border-radius: 12px;
        overflow: hidden;
    }

    .editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid #333;
    }

    .editor-title {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
    }

    .editor-actions {
        display: flex;
        gap: 8px;
    }

    .btn {
        padding: 8px 16px;
        font-size: 13px;
        font-weight: 500;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
    }

    .btn-primary {
        background: #3b82f6;
        color: white;
    }

    .btn-primary:hover {
        background: #2563eb;
    }

    .btn-secondary {
        background: #2a2a2a;
        color: #e0e0e0;
        border: 1px solid #404040;
    }

    .btn-secondary:hover {
        background: #333;
    }

    /* Code Editor */
    .code-editor {
        display: flex;
        min-height: 500px;
        max-height: 70vh;
        overflow: auto;
        background: #1a1a1a;
    }

    .line-numbers {
        padding: 16px 0;
        background: #1e1e1e;
        border-right: 1px solid #333;
        text-align: right;
        user-select: none;
        min-width: 50px;
    }

    .line-number {
        padding: 0 12px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        line-height: 1.6;
        color: #555;
    }

    .line-number.active {
        color: #888;
    }

    .code-area {
        flex: 1;
        position: relative;
        overflow: auto;
    }

    .code-textarea {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        padding: 16px;
        background: transparent;
        border: none;
        color: transparent;
        caret-color: #fff;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        line-height: 1.6;
        resize: none;
        white-space: pre;
        overflow: auto;
        z-index: 2;
    }

    .code-textarea:focus {
        outline: none;
    }

    .code-highlight {
        padding: 16px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        line-height: 1.6;
        white-space: pre;
        pointer-events: none;
        min-height: 100%;
    }

    /* Scrollbar */
    .code-editor::-webkit-scrollbar,
    .code-textarea::-webkit-scrollbar {
        width: 12px;
        height: 12px;
    }

    .code-editor::-webkit-scrollbar-track,
    .code-textarea::-webkit-scrollbar-track {
        background: #1a1a1a;
    }

    .code-editor::-webkit-scrollbar-thumb,
    .code-textarea::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 6px;
        border: 2px solid #1a1a1a;
    }

    .code-editor::-webkit-scrollbar-thumb:hover,
    .code-textarea::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    .code-editor::-webkit-scrollbar-corner {
        background: #1a1a1a;
    }

    /* Syntax Highlighting */
    .function { color: #4ade80; font-weight: 500; }
    .string { color: #f97316; }
    .number { color: #60a5fa; }
    .operator { color: #e0e0e0; }
    .parenthesis { color: #888; }
    .bracket { color: #a78bfa; }

    /* Notification */
    .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        background: #22c55e;
        color: white;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.3s;
        pointer-events: none;
        z-index: 1001;
    }

    .notification.show {
        opacity: 1;
        transform: translateY(0);
    }

    .notification.error {
        background: #ef4444;
    }

    /* Sidebar */
    .sidebar {
        position: fixed;
        top: 0;
        right: -350px;
        width: 350px;
        height: 100vh;
        background: #232323;
        border-left: 1px solid #333;
        transition: right 0.3s ease;
        z-index: 1000;
        display: flex;
        flex-direction: column;
    }

    .sidebar.open {
        right: 0;
    }

    .sidebar-header {
        padding: 16px 20px;
        border-bottom: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .sidebar-title {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
    }

    .sidebar-close {
        background: none;
        border: none;
        color: #888;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
    }

    .sidebar-close:hover {
        color: #fff;
    }

    .sidebar-search {
        padding: 12px 20px;
        border-bottom: 1px solid #333;
    }

    .sidebar-search input {
        width: 100%;
        padding: 10px 12px;
        background: #191919;
        border: 1px solid #404040;
        border-radius: 6px;
        color: #e0e0e0;
        font-size: 14px;
    }

    .sidebar-search input:focus {
        outline: none;
        border-color: #3b82f6;
    }

    .sidebar-search input::placeholder {
        color: #666;
    }

    .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 8px 0;
    }

    .function-item {
        border-bottom: 1px solid #2a2a2a;
    }

    .function-header {
        padding: 12px 20px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background 0.2s;
    }

    .function-header:hover {
        background: #2a2a2a;
    }

    .function-name {
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        color: #4ade80;
        font-weight: 500;
    }

    .function-arrow {
        color: #666;
        transition: transform 0.2s;
        font-size: 12px;
    }

    .function-item.open .function-arrow {
        transform: rotate(180deg);
    }

    .function-details {
        display: none;
        padding: 0 20px 16px 20px;
        background: #1a1a1a;
    }

    .function-item.open .function-details {
        display: block;
    }

    .function-syntax {
        background: #191919;
        padding: 10px 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: #f97316;
        border: 1px solid #333;
    }

    .function-description {
        font-size: 13px;
        color: #888;
        line-height: 1.5;
    }

    .function-example {
        margin-top: 10px;
        padding: 10px 12px;
        background: #191919;
        border-radius: 6px;
        border: 1px solid #333;
    }

    .function-example-label {
        font-size: 11px;
        color: #666;
        text-transform: uppercase;
        margin-bottom: 6px;
    }

    .function-example-code {
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: #e0e0e0;
    }

    .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
        z-index: 999;
    }

    .sidebar-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    /* Autocomplete Dropdown */
    .autocomplete-dropdown {
        position: absolute;
        background: #2a2a2a;
        border: 1px solid #444;
        border-radius: 6px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 100;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        min-width: 200px;
    }

    .autocomplete-dropdown.show {
        display: block;
    }

    .autocomplete-item {
        padding: 8px 12px;
        cursor: pointer;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        color: #4ade80;
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
        background: #3b82f6;
        color: white;
    }

    .autocomplete-dropdown::-webkit-scrollbar {
        width: 8px;
    }

    .autocomplete-dropdown::-webkit-scrollbar-track {
        background: #2a2a2a;
    }

    .autocomplete-dropdown::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
    }

    /* Parameter Hint */
    .parameter-hint {
        position: absolute;
        background: #3a3a3a;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 4px 8px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: #e0e0e0;
        z-index: 100;
        display: none;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .parameter-hint.show {
        display: block;
    }

    .parameter-hint .param {
        color: #888;
    }

    .parameter-hint .param.active {
        color: #4ade80;
        font-weight: 600;
    }

    .parameter-hint .function-name {
        color: #4ade80;
    }

    /* Compiler Section */
    .compiler-card {
        background: #232323;
        border: 1px solid #333;
        border-radius: 12px;
        overflow: hidden;
        margin-top: 24px;
        position: relative;
    }

    .compiler-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid #333;
    }

    .compiler-title {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
    }

    .compiler-content {
        padding: 20px;
    }

    .fields-section {
        margin-bottom: 20px;
    }

    .fields-title {
        font-size: 14px;
        font-weight: 500;
        color: #888;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .fields-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 12px;
    }

    .field-item {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .field-label {
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: #a78bfa;
        font-weight: 500;
    }

    .field-input {
        padding: 10px 12px;
        background: #1a1a1a;
        border: 1px solid #404040;
        border-radius: 6px;
        color: #e0e0e0;
        font-size: 14px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
    }

    .field-input:focus {
        outline: none;
        border-color: #3b82f6;
    }

    .field-input::placeholder {
        color: #555;
    }

    .no-fields {
        color: #666;
        font-size: 14px;
        font-style: italic;
        padding: 20px;
        text-align: center;
        background: #1a1a1a;
        border-radius: 8px;
    }

    .output-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #333;
    }

    .output-title {
        font-size: 14px;
        font-weight: 500;
        color: #888;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .output-box {
        padding: 16px;
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        color: #e0e0e0;
        min-height: 60px;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .wip-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(25, 25, 25, 0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        backdrop-filter: blur(2px);
    }

    .wip-badge {
        background: linear-gradient(135deg, #f97316, #ea580c);
        color: white;
        padding: 12px 32px;
        border-radius: 8px;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 2px;
        text-transform: uppercase;
        box-shadow: 0 4px 20px rgba(249, 115, 22, 0.4);
        margin-bottom: 12px;
    }

    .wip-text {
        color: #888;
        font-size: 14px;
    }

    @media (max-width: 768px) {
        .sidebar {
            width: 100%;
            right: -100%;
        }
        .editor-header {
            flex-direction: column;
            gap: 12px;
            align-items: flex-start;
        }
        .editor-actions {
            width: 100%;
            flex-wrap: wrap;
        }
        .btn {
            flex: 1;
            min-width: 120px;
        }
    }
</style>
</head>
<body>

<!-- Header -->
<div class="header">
    <div class="header-left">
        <div class="status-dot"></div>
        <span class="header-title"><a href="../" style="color: inherit; text-decoration: none;">ProcessPlan Tools</a> | Formula Editor</span>
    </div>
    <button class="toggle-sidebar-btn" onclick="toggleSidebar()">
        <span>ðŸ“š</span> Functions
    </button>
</div>

<!-- Sidebar Overlay -->
<div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>

<!-- Sidebar -->
<div class="sidebar" id="sidebar">
    <div class="sidebar-header">
        <span class="sidebar-title">Function Reference</span>
        <button class="sidebar-close" onclick="toggleSidebar()">Ã—</button>
    </div>
    <div class="sidebar-search">
        <input type="text" id="functionSearch" placeholder="Search functions..." oninput="filterFunctions()">
    </div>
    <div class="sidebar-content" id="functionList">
    </div>
</div>

<!-- Main Content -->
<div class="main-content">
    <div class="editor-card">
        <div class="editor-header">
            <span class="editor-title">Formula Editor</span>
            <div class="editor-actions">
                <button class="btn btn-secondary" onclick="copyFormatted()">Copy Formatted</button>
                <button class="btn btn-secondary" onclick="copyRaw()">Copy Raw</button>
                <button class="btn btn-secondary" onclick="clearEditor()">Clear</button>
            </div>
        </div>
        <div class="code-editor" id="codeEditor">
            <div class="line-numbers" id="lineNumbers"></div>
            <div class="code-area">
                <div class="code-highlight" id="codeHighlight"></div>
                <textarea class="code-textarea" id="codeTextarea" placeholder="Paste or type your formula here..." spellcheck="false"></textarea>
                <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
                <div class="parameter-hint" id="parameterHint"></div>
            </div>
        </div>
    </div>

    <!-- Compiler Section -->
    <div class="compiler-card">
        <!-- <div class="wip-overlay">
            <div class="wip-badge">ðŸš§ Work in Progress</div>
            <div class="wip-text">Formula compilation coming soon</div>
        </div> -->
        <div class="compiler-header">
            <span class="compiler-title">Formula Compiler (WIP)</span>
            <button class="btn btn-primary" onclick="compileFormula()">Compile</button>
        </div>
        <div class="compiler-content">
            <div class="fields-section">
                <div class="fields-title">Field Values</div>
                <div id="fieldsContainer" class="fields-grid">
                    <div class="no-fields">No fields detected. Add field tokens like [[FieldName]] to your formula.</div>
                </div>
            </div>
            <div class="output-section">
                <div class="output-title">Compiled Output</div>
                <div id="compilerOutput" class="output-box">Output will appear here after compilation...</div>
            </div>
        </div>
    </div>
</div>

<div id="notification" class="notification"></div>

<script>
const FUNCTIONS = new Set([
    '!CONTAINS', '!EQUALS', 'ANYTRUE', 'APPEND', 'BDATE', 'BENUM', 'CALC', 'CEILING',
    'CONTAINS', 'DATEADD', 'DATEDIFF', 'DATELIST', 'DATEPART', 'DATEPATTERN', 'DATEROUND',
    'DATESERIAL', 'DATETIMEMERGE', 'EMAILSPLIT', 'ENCLOSE', 'EQUALS', 'FIRSTVALUE',
    'FISCALMONTH', 'FISCALYEAR', 'FLOOR', 'FORMAT', 'GTDATE', 'GTEDATE', 'GTENUM', 'GTNUM',
    'HASVALUE', 'IF', 'INSTANCECOUNT', 'INSTANCETASKCOUNT', 'INSTANCEUPDATE', 'ISCONTEXT',
    'ISEMPTY', 'ISPUBLICUSER', 'ISTRUE', 'JSONENCODE', 'JSONEXTRACT', 'JSONFIFO', 'JSONINDEX',
    'JSONQUERY', 'JSONREMOVE', 'JSONUPDATE', 'LEFT', 'LEFTOF', 'LEFTOFLAST', 'LENGTH',
    'LINESPLIT', 'LISTASLINES', 'LISTCOUNT', 'LISTDIFF', 'LISTINDEX', 'LISTINTERSECT',
    'LISTITEMAPPEND', 'LISTITEMCONTAINS', 'LISTITEMENDSWITH', 'LISTITEMLEFT', 'LISTITEMLEFTOF',
    'LISTITEMPREPEND', 'LISTITEMREGEX', 'LISTITEMRIGHT', 'LISTITEMRIGHTOF', 'LISTITEMSTARTSWITH',
    'LISTJOIN', 'LISTMERGE', 'LISTUNIQUE', 'LOWERCASE', 'LTDATE', 'LTEDATE', 'LTENUM', 'LTNUM',
    'MAX', 'MIN', 'MONTH', 'MONTHDAY', 'MONTHLASTDAY', 'NORMALIZETEXT', 'NOT', 'NUM', 'NUMSPLIT',
    'PARSE', 'PARTITION', 'RANDOMNUM', 'REGEXFIND', 'REGEXWORDSONLY', 'REMOVECHARS',
    'REMOVEDIACRITICS', 'REMOVESPACES', 'REMOVESYMBOLS', 'REPLACE', 'RIGHT', 'RIGHTOF',
    'RIGHTOFLAST', 'ROUND', 'SPLIT', 'SUM', 'TABLEAVG', 'TABLEJSON', 'TABLELOOKUP', 'TABLESUM',
    'TASKLOOKUP', 'TASKREPORT', 'TITLECASE', 'TRIM', 'UPPERCASE', 'URLENCODE', 'WORDSPLIT',
    'WORKDAY', 'YEAR'
]);

const textarea = document.getElementById('codeTextarea');
const highlight = document.getElementById('codeHighlight');
const lineNumbers = document.getElementById('lineNumbers');
const codeEditor = document.getElementById('codeEditor');
const autocompleteDropdown = document.getElementById('autocompleteDropdown');
const parameterHint = document.getElementById('parameterHint');

let isFormatting = false;

// Autocomplete state
let autocompleteVisible = false;
let autocompleteItems = [];
let selectedIndex = 0;
let autocompleteStart = -1;

// Sorted function list for autocomplete
const FUNCTION_LIST = Array.from(FUNCTIONS).sort();

// Function parameters map (from official ProcessPlan documentation)
const FUNCTION_PARAMS = {
    '!CONTAINS': ['DoesThisValueNotExist', 'AnywhereInsideThisValue'],
    '!EQUALS': ['DoesThisValue', 'NotEqualThisValue', 'OrThisValue', '...'],
    'ANYTRUE': ['IsThisFunctionTrue', 'IsThisFunctionTrue', '...'],
    'APPEND': ['Separator', 'Item1', 'Item2', '...'],
    'BDATE': ['IsThisDate', 'GreaterThanThisDate', 'AndLessThanThisDate'],
    'BENUM': ['IsThisNum', 'GreaterThanOrEqualToThisNum', 'AndLessThanOrEqualToThisNum'],
    'CALC': ['MathematicalExpression'],
    'CEILING': ['AnyNumber'],
    'CONTAINS': ['DoesThisValueExist', 'AnywhereInsideThisValue'],
    'DATEADD': ['UnitToIncrement', 'IncrementBy', 'DateToIncrement', 'OptionalMinDate'],
    'DATEDIFF': ['ReturnUnit', 'SubtractThisDate', 'FromThisDate'],
    'DATELIST': ['StartDate', 'EndDate'],
    'DATEPART': ['DatePart', 'DateValue'],
    'DATEPATTERN': ['DateRecurrencePattern', 'EndDateToGenerate', 'RecurrenceAnchorDate', 'StartFromStartDate'],
    'DATEROUND': ['UnitToRoundTo', 'IntervalNum', 'DateToRound'],
    'DATESERIAL': ['Year', 'Month', 'Day'],
    'DATETIMEMERGE': ['DateValue', 'TimeValue'],
    'EMAILSPLIT': ['ReturnIndex', 'EmailAddressText'],
    'ENCLOSE': ['ValueYouWantToHide'],
    'EQUALS': ['DoesThisValue', 'EqualThisValue', 'AndThisValue', '...'],
    'FIRSTVALUE': ['Item1', 'Item2', 'Item3', '...'],
    'FISCALMONTH': ['FiscalYearStartMonthNumber', 'DateToEvaluate'],
    'FISCALYEAR': ['FiscalYearStartMonthNumber', 'DateToEvaluate'],
    'FLOOR': ['AnyNumber'],
    'FORMAT': ['FormatString', 'NumberOrDate'],
    'GTDATE': ['IsThisDate', 'GreaterThanThisDate'],
    'GTEDATE': ['Date1', 'Date2'],
    'GTENUM': ['IsThisNumber', 'GreaterOrEqualToThisNumber'],
    'GTNUM': ['IsThisNumber', 'GreaterThanThisNumber'],
    'HASVALUE': ['DoesAnyValueExistHere'],
    'IF': ['ConditionCheck', 'IfTrueReturnThis', 'AnotherCondition', 'IfTrueReturnThis', 'OptionalIfFalse'],
    'INSTANCECOUNT': ['TableID', 'TableQuery'],
    'INSTANCETASKCOUNT': ['ProcessInstanceID', 'TemplateTaskID'],
    'INSTANCEUPDATE': ['FieldIDToUpdate', 'TableIDToSearch', 'SearchQuery', 'NewFieldValue'],
    'ISCONTEXT': ['ContextIDToTest', 'AnotherOptionalID', '...'],
    'ISEMPTY': ['IsTheValueEmpty'],
    'ISPUBLICUSER': [],
    'ISTRUE': ['IsThisTrue', 'OptionalIsThisTrue', '...'],
    'JSONENCODE': ['TextParameter'],
    'JSONEXTRACT': ['AnyTextContainingJSON'],
    'JSONFIFO': ['ExistingJsonArray', 'NewJsonObjectToAdd', 'MaximumLength'],
    'JSONINDEX': ['IndexToRetrieve', 'ExistingJsonArray'],
    'JSONQUERY': ['JSONPropertyName', 'JSONContainingTheProperty'],
    'JSONREMOVE': ['IndexToRemove', 'ExistingJsonArray'],
    'JSONUPDATE': ['ExistingJsonObject', 'PropertyName', 'PropertyValue'],
    'LEFT': ['Count', 'Value'],
    'LEFTOF': ['ReturnLeftOf', 'SearchInString'],
    'LEFTOFLAST': ['ReturnLeftOf', 'SearchInString'],
    'LENGTH': ['CharacterString'],
    'LINESPLIT': ['IndexOfSplitListToReturn', 'TextToSplit'],
    'LISTASLINES': ['SemicolonSeparatedList'],
    'LISTCOUNT': ['Item1', 'Item2', '...'],
    'LISTDIFF': ['SemicolonSeparatedList1', 'SemicolonSeparatedList2'],
    'LISTINDEX': ['ReturnIndex', 'SemicolonSeparatedTextList'],
    'LISTINTERSECT': ['SemicolonSeparatedList1', 'SemicolonSeparatedList2'],
    'LISTITEMAPPEND': ['AppendText', 'SemicolonSeparatedList'],
    'LISTITEMCONTAINS': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTITEMENDSWITH': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTITEMLEFT': ['NumberOfCharsToReturn', 'SemicolonSeparatedList'],
    'LISTITEMLEFTOF': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTITEMPREPEND': ['PrependText', 'SemicolonSeparatedList'],
    'LISTITEMREGEX': ['RegEx', 'SemicolonSeparatedList'],
    'LISTITEMRIGHT': ['NumberOfCharsToReturn', 'SemicolonSeparatedList'],
    'LISTITEMRIGHTOF': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTITEMSTARTSWITH': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTJOIN': ['NewListItemSeparator', 'SemicolonSeparatedList'],
    'LISTMERGE': ['SemicolonSeparatedList1', 'SemicolonSeparatedList2'],
    'LISTUNIQUE': ['SemicolonSeparatedList'],
    'LOWERCASE': ['String'],
    'LTDATE': ['IsThisDate', 'LessThanThisDate'],
    'LTEDATE': ['IsThisDate', 'LessThanOrEqualToThisDate'],
    'LTENUM': ['Value1', 'Value2'],
    'LTNUM': ['IsThisValue', 'LessThanThisValue'],
    'MAX': ['Parameter1', 'Parameter2', '...'],
    'MIN': ['Parameter1', 'Parameter2', '...'],
    'MONTH': ['DateValue'],
    'MONTHDAY': ['DateValue'],
    'MONTHLASTDAY': ['DateValue', 'OptionalAddOrSubtractDay'],
    'NORMALIZETEXT': ['TextValue'],
    'NOT': ['BooleanParameter'],
    'NUM': ['Parameter'],
    'NUMSPLIT': ['Parameter'],
    'PARSE': ['GetRightOfThisText', 'GetLeftOfThisText', 'SearchWithinThisText'],
    'PARTITION': ['NumberToBePartitioned', 'Divisor'],
    'RANDOMNUM': ['MinimumNumber', 'MaximumNumber'],
    'REGEXFIND': ['RegEx', 'StringToSearch'],
    'REGEXWORDSONLY': ['TextToConvertToRegex'],
    'REMOVECHARS': ['Value', 'CharsToRemove'],
    'REMOVEDIACRITICS': ['Value'],
    'REMOVESPACES': ['Value'],
    'REMOVESYMBOLS': ['Value'],
    'REPLACE': ['SearchForText', 'NewText', 'SearchWithinText'],
    'RIGHT': ['Count', 'Value'],
    'RIGHTOF': ['ReturnRightOf', 'SearchInString'],
    'RIGHTOFLAST': ['ReturnRightOf', 'SearchInString'],
    'ROUND': ['NumOfDecimals', 'AnyNumber'],
    'SPLIT': ['CharacterToSplitOn', 'IndexOfSplitToReturn', 'TextToSplit'],
    'SUM': ['Parameter1', 'Parameter2', '...'],
    'TABLEAVG': ['FieldID', 'TableID', 'TableQuery'],
    'TABLEJSON': ['NumberOfColumns', 'ProcessTableID', 'OptionalTableQuery'],
    'TABLELOOKUP': ['FieldTokenToRetrieve', 'TableID', 'TableQuery'],
    'TABLESUM': ['FieldID', 'TableID', 'TableQuery'],
    'TASKLOOKUP': ['FieldTokenToRetrieve', 'TemplateTaskID', 'TaskQuery'],
    'TASKREPORT': ['TextBlockID', 'ProcessInstanceID', 'IncludeSubprocessTask', 'FilterQuery'],
    'TITLECASE': ['TextParameter'],
    'TRIM': ['TextToTrim'],
    'UPPERCASE': ['String'],
    'URLENCODE': ['CharacterToEncode'],
    'WORDSPLIT': ['ReturnWordIndex', 'PlainText'],
    'WORKDAY': ['WorkScheduleID', 'WorkdaysToSkip', 'DateToStartEvaluatingFrom'],
    'YEAR': ['DateValue']
};

// Get current word being typed (after =)
function getCurrentFunctionPrefix() {
    const cursorPos = textarea.selectionStart;
    const text = textarea.value.substring(0, cursorPos);
    
    // Find the last = sign and get text after it
    const lastEquals = text.lastIndexOf('=');
    if (lastEquals === -1) return null;
    
    const afterEquals = text.substring(lastEquals + 1);
    
    // Check if we're still typing the function name (only letters)
    if (/^[a-zA-Z]*$/.test(afterEquals)) {
        return { prefix: afterEquals.toUpperCase(), start: lastEquals };
    }
    
    return null;
}

// Filter and show autocomplete
function updateAutocomplete() {
    const result = getCurrentFunctionPrefix();
    
    if (result === null) {
        hideAutocomplete();
        return;
    }
    
    const { prefix, start } = result;
    autocompleteStart = start;
    
    // Filter functions that start with the prefix
    autocompleteItems = FUNCTION_LIST.filter(fn => fn.startsWith(prefix));
    
    if (autocompleteItems.length === 0) {
        hideAutocomplete();
        return;
    }
    
    selectedIndex = 0;
    renderAutocomplete();
    positionAutocomplete();
    showAutocomplete();
}

function renderAutocomplete() {
    autocompleteDropdown.innerHTML = autocompleteItems.map((item, index) => 
        `<div class="autocomplete-item${index === selectedIndex ? ' selected' : ''}" data-index="${index}" data-value="${item}">=${item}()</div>`
    ).join('');
    
    // Add click handlers
    autocompleteDropdown.querySelectorAll('.autocomplete-item').forEach(el => {
        el.addEventListener('click', () => {
            selectAutocompleteItem(parseInt(el.dataset.index));
        });
    });
}

function positionAutocomplete() {
    // Get cursor position in textarea
    const cursorPos = textarea.selectionStart;
    
    // Create a temporary span to measure text position
    const textBeforeCursor = textarea.value.substring(0, cursorPos);
    const lines = textBeforeCursor.split('\n');
    const currentLineIndex = lines.length - 1;
    const currentLineText = lines[currentLineIndex];
    
    // Calculate position
    const lineHeight = 20.8; // Approximate line height (13px * 1.6)
    const charWidth = 7.8; // Approximate character width for monospace
    
    const top = (currentLineIndex + 1) * lineHeight + 16; // +16 for padding
    const left = currentLineText.length * charWidth + 16 + 50; // +50 for line numbers width
    
    autocompleteDropdown.style.top = `${Math.min(top, 400)}px`;
    autocompleteDropdown.style.left = `${Math.min(left, 300)}px`;
}

function showAutocomplete() {
    autocompleteDropdown.classList.add('show');
    autocompleteVisible = true;
}

function hideAutocomplete() {
    autocompleteDropdown.classList.remove('show');
    autocompleteVisible = false;
    autocompleteItems = [];
    selectedIndex = 0;
}

function selectAutocompleteItem(index) {
    if (index < 0 || index >= autocompleteItems.length) return;
    
    const selectedFunction = autocompleteItems[index];
    const cursorPos = textarea.selectionStart;
    
    // Replace from = to cursor with the selected function
    const before = textarea.value.substring(0, autocompleteStart);
    const after = textarea.value.substring(cursorPos);
    
    const insertion = `=${selectedFunction}(`;
    textarea.value = before + insertion + after;
    
    // Position cursor inside the parentheses
    const newPos = autocompleteStart + insertion.length;
    textarea.setSelectionRange(newPos, newPos);
    
    hideAutocomplete();
    updateEditor();
    textarea.focus();
}

function navigateAutocomplete(direction) {
    if (!autocompleteVisible || autocompleteItems.length === 0) return;
    
    selectedIndex += direction;
    
    if (selectedIndex < 0) selectedIndex = autocompleteItems.length - 1;
    if (selectedIndex >= autocompleteItems.length) selectedIndex = 0;
    
    renderAutocomplete();
    
    // Scroll selected item into view
    const selectedEl = autocompleteDropdown.querySelector('.autocomplete-item.selected');
    if (selectedEl) {
        selectedEl.scrollIntoView({ block: 'nearest' });
    }
}

// Parameter hint functions
function getCurrentFunctionContext() {
    const cursorPos = textarea.selectionStart;
    const text = textarea.value.substring(0, cursorPos);
    
    // Track function calls and their positions
    let functionStack = [];
    let bracketDepth = 0;
    let i = 0;
    
    while (i < text.length) {
        const char = text[i];
        
        // Track brackets to ignore content inside [[ ]]
        if (char === '[') bracketDepth++;
        if (char === ']') bracketDepth = Math.max(0, bracketDepth - 1);
        
        // Look for function pattern: =FUNCTIONNAME( or just FUNCTIONNAME( for nested
        if (bracketDepth === 0) {
            // Check for function start
            let functionMatch = null;
            
            // Check if this could be start of a function name
            if (char === '=' || (functionStack.length > 0 && /[A-Z!]/.test(char))) {
                let nameStart = char === '=' ? i + 1 : i;
                let name = '';
                let j = nameStart;
                
                while (j < text.length && /[A-Z!]/.test(text[j])) {
                    name += text[j];
                    j++;
                }
                
                if (text[j] === '(' && FUNCTIONS.has(name)) {
                    functionStack.push({
                        name: name,
                        paramIndex: 0,
                        start: i
                    });
                    i = j; // Skip to the (
                }
            }
            
            // Count semicolons for current function's parameter index
            if (char === ';' && functionStack.length > 0) {
                functionStack[functionStack.length - 1].paramIndex++;
            }
            
            // Handle closing parenthesis
            if (char === ')' && functionStack.length > 0) {
                functionStack.pop();
            }
        }
        
        i++;
    }
    
    // Return the innermost function context
    if (functionStack.length > 0) {
        return functionStack[functionStack.length - 1];
    }
    
    return null;
}

function updateParameterHint() {
    const context = getCurrentFunctionContext();
    
    if (!context || !FUNCTION_PARAMS[context.name]) {
        hideParameterHint();
        return;
    }
    
    const params = FUNCTION_PARAMS[context.name];
    if (params.length === 0) {
        hideParameterHint();
        return;
    }
    
    // Build the hint HTML
    const paramHtml = params.map((param, index) => {
        const isActive = index === context.paramIndex || 
                        (index === params.length - 1 && context.paramIndex >= params.length);
        return `<span class="param${isActive ? ' active' : ''}">${param}</span>`;
    }).join('<span class="param">; </span>');
    
    parameterHint.innerHTML = `<span class="function-name">${context.name}</span>(${paramHtml})`;
    
    positionParameterHint();
    showParameterHint();
}

function positionParameterHint() {
    const cursorPos = textarea.selectionStart;
    const textBeforeCursor = textarea.value.substring(0, cursorPos);
    const lines = textBeforeCursor.split('\n');
    const currentLineIndex = lines.length - 1;
    const currentLineText = lines[currentLineIndex];
    
    const lineHeight = 20.8;
    const charWidth = 7.8;
    
    // Position above the current line
    const top = currentLineIndex * lineHeight + 16 - 28; // -28 to go above
    const left = currentLineText.length * charWidth + 16 + 50;
    
    parameterHint.style.top = `${Math.max(top, 0)}px`;
    parameterHint.style.left = `${Math.min(left, 400)}px`;
}

function showParameterHint() {
    parameterHint.classList.add('show');
}

function hideParameterHint() {
    parameterHint.classList.remove('show');
}

// Format formula with indentation
function formatFormula(formula) {
    let result = '';
    let indentLevel = 0;
    const indentSize = 2;
    let bracketDepth = 0;

    for (let i = 0; i < formula.length; i++) {
        const char = formula[i];

        if (char === '[') bracketDepth++;
        if (char === ']') bracketDepth = Math.max(0, bracketDepth - 1);

        if (char === '(') {
            result += char;
            if (bracketDepth === 0) {
                indentLevel++;
                if (i + 1 < formula.length && formula[i + 1] !== ')') {
                    result += '\n' + ' '.repeat(indentLevel * indentSize);
                }
            }
        } else if (char === ')') {
            if (bracketDepth === 0) {
                indentLevel = Math.max(0, indentLevel - 1);
                if (result.trim().slice(-1) !== '(') {
                    result += '\n' + ' '.repeat(indentLevel * indentSize);
                }
            }
            result += char;
        } else if ((char === ',' || char === ';') && bracketDepth === 0) {
            result += char + '\n' + ' '.repeat(indentLevel * indentSize);
        } else if (char.match(/\s/)) {
            if (bracketDepth > 0) {
                result += char;
            }
        } else {
            result += char;
        }
    }

    return result;
}




// Tokenize for syntax highlighting
function tokenize(code) {
    const tokens = [];
    let i = 0;
    let functionDepthStack = [];

    while (i < code.length) {
        if (/\s/.test(code[i])) {
            let value = '';
            while (i < code.length && /\s/.test(code[i])) {
                value += code[i];
                i++;
            }
            tokens.push({ type: 'whitespace', value });
            continue;
        }

        if (code[i] === '"') {
            let value = '"';
            i++;
            while (i < code.length && code[i] !== '"') {
                value += code[i];
                i++;
            }
            if (i < code.length) {
                value += '"';
                i++;
            }
            tokens.push({ type: 'string', value });
            continue;
        }

        if (code[i] === "'") {
            let value = "'";
            i++;
            while (i < code.length && code[i] !== "'") {
                value += code[i];
                i++;
            }
            if (i < code.length) {
                value += "'";
                i++;
            }
            tokens.push({ type: 'string', value });
            continue;
        }

        if (/\d/.test(code[i])) {
            let value = '';
            while (i < code.length && /[\d.]/.test(code[i])) {
                value += code[i];
                i++;
            }
            tokens.push({ type: 'number', value });
            continue;
        }

        if (/[a-zA-Z_]/.test(code[i])) {
            let value = '';
            while (i < code.length && /[a-zA-Z0-9_]/.test(code[i])) {
                value += code[i];
                i++;
            }
            if (code[i] === '(' && FUNCTIONS.has(value.toUpperCase())) {
                tokens.push({ type: 'function', value: value + '(' });
                functionDepthStack.push(1);
                i++;
            } else {
                tokens.push({ type: 'identifier', value });
            }
            continue;
        }

        if (code[i] === '(') {
            for (let j = 0; j < functionDepthStack.length; j++) {
                functionDepthStack[j]++;
            }
            tokens.push({ type: 'parenthesis', value: '(' });
            i++;
            continue;
        }

        if (code[i] === ')') {
            let isClosingFunction = false;
            for (let j = functionDepthStack.length - 1; j >= 0; j--) {
                functionDepthStack[j]--;
                if (functionDepthStack[j] === 0) {
                    isClosingFunction = true;
                    functionDepthStack.splice(j, 1);
                    break;
                }
            }
            tokens.push({ type: isClosingFunction ? 'function' : 'parenthesis', value: ')' });
            i++;
            continue;
        }

        if (/[+\-*\/=<>&|;,]/.test(code[i])) {
            tokens.push({ type: 'operator', value: code[i] });
            i++;
            continue;
        }

        if (code[i] === '[' || code[i] === ']') {
            tokens.push({ type: 'bracket', value: code[i] });
            i++;
            continue;
        }

        tokens.push({ type: 'other', value: code[i] });
        i++;
    }

    return tokens;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function applySyntaxHighlighting(code) {
    const tokens = tokenize(code);
    return tokens.map(token => {
        const escaped = escapeHtml(token.value);
        switch (token.type) {
            case 'function': return `<span class="function">${escaped}</span>`;
            case 'string': return `<span class="string">${escaped}</span>`;
            case 'number': return `<span class="number">${escaped}</span>`;
            case 'operator': return `<span class="operator">${escaped}</span>`;
            case 'parenthesis': return `<span class="parenthesis">${escaped}</span>`;
            case 'bracket': return `<span class="bracket">${escaped}</span>`;
            default: return escaped;
        }
    }).join('');
}

function updateLineNumbers(code) {
    const lines = code.split('\n');
    lineNumbers.innerHTML = lines.map((_, i) => 
        `<div class="line-number">${i + 1}</div>`
    ).join('');
}

function updateEditor() {
    const code = textarea.value;
    highlight.innerHTML = applySyntaxHighlighting(code) + '\n';
    updateLineNumbers(code);
}

function formatLive() {
    const raw = textarea.value;
    const formatted = addIndentationAndSpacing(raw);
    const highlighted = applySyntaxHighlighting(formatted);
    formattedCode.innerHTML = highlighted;
}

// Handle paste - format the pasted content
textarea.addEventListener('paste', (e) => {
    e.preventDefault();
    const pastedText = e.clipboardData.getData('text');
    const formatted = formatFormula(pastedText);
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const before = textarea.value.substring(0, start);
    const after = textarea.value.substring(end);
    
    textarea.value = before + formatted + after;
    
    const newPos = start + formatted.length;
    textarea.setSelectionRange(newPos, newPos);
    
    updateEditor();
    hideAutocomplete();
    updateParameterHint();
    extractAndDisplayFields();
    showNotification('Formula formatted!');
});

// Hide autocomplete when clicking outside
document.addEventListener('click', (e) => {
    if (!autocompleteDropdown.contains(e.target) && e.target !== textarea) {
        hideAutocomplete();
    }
});

// Update parameter hint on cursor movement
textarea.addEventListener('click', () => {
    updateParameterHint();
});

textarea.addEventListener('keyup', (e) => {
    // Update on arrow keys for cursor movement
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key)) {
        updateParameterHint();
    }
});

// Handle input for live updates
textarea.addEventListener('input', () => {
    updateEditor();
    updateAutocomplete();
    updateParameterHint();
    extractAndDisplayFields();
    formatLive();
});

// Sync scroll between textarea and highlight
textarea.addEventListener('scroll', () => {
    highlight.scrollTop = textarea.scrollTop;
    highlight.scrollLeft = textarea.scrollLeft;
});

// Handle tab key
textarea.addEventListener('keydown', (e) => {
    // Handle autocomplete navigation
    if (autocompleteVisible) {
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            navigateAutocomplete(1);
            return;
        }
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            navigateAutocomplete(-1);
            return;
        }
        if (e.key === 'Enter') {
            e.preventDefault();
            selectAutocompleteItem(selectedIndex);
            return;
        }
        if (e.key === 'Escape') {
            e.preventDefault();
            hideAutocomplete();
            return;
        }
    }
    
    // Handle Enter inside a function (after opening parenthesis)
    if (e.key === 'Enter' && !autocompleteVisible) {
        const cursorPos = textarea.selectionStart;
        const textBefore = textarea.value.substring(0, cursorPos);
        const textAfter = textarea.value.substring(cursorPos);
        
        // Check if we're right after an opening parenthesis of a function
        const charBefore = textBefore.slice(-1);
        
        if (charBefore === '(') {
            e.preventDefault();

            const indentLevel = getIndentLevel(textBefore);
            const indentSize = 2;
            const newIndent = ' '.repeat(indentLevel * indentSize);
            const closingIndent = ' '.repeat((indentLevel - 1) * indentSize);

            // Check if a closing parenthesis already exists ahead
            const hasClosingParenAhead = /^\s*\)/.test(textAfter);

            const insertion =
                '\n' +
                newIndent +
                (hasClosingParenAhead ? '\n' + closingIndent : '\n' + closingIndent + ')');

            textarea.value = textBefore + insertion + textAfter;

            // Cursor goes on the indented line
            const newPos = cursorPos + 1 + newIndent.length;
            textarea.setSelectionRange(newPos, newPos);

            updateEditor();
            return;
        }

    }
    
    if (e.key === 'Tab') {
        e.preventDefault();
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        textarea.value = textarea.value.substring(0, start) + '  ' + textarea.value.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + 2;
        updateEditor();
    }
});

// Calculate indent level based on unmatched opening parens (outside brackets)
function getIndentLevel(text) {
    let level = 0;
    let bracketDepth = 0;
    
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (char === '[') bracketDepth++;
        if (char === ']') bracketDepth = Math.max(0, bracketDepth - 1);
        
        if (bracketDepth === 0) {
            if (char === '(') level++;
            if (char === ')') level = Math.max(0, level - 1);
        }
    }
    
    return level;
}

// Copy formatted (with indentation)
function copyFormatted() {
    const code = textarea.value;
    if (!code.trim()) {
        showNotification('Nothing to copy!', 'error');
        return;
    }
    navigator.clipboard.writeText(code)
        .then(() => showNotification('Copied formatted!'))
        .catch(() => showNotification('Failed to copy', 'error'));
}

// Copy raw (without formatting)
function copyRaw() {
    const code = textarea.value;
    if (!code.trim()) {
        showNotification('Nothing to copy!', 'error');
        return;
    }
    let raw = code.replace(/[\n\r\t]+/g, '');
    raw = raw.replace(/\(\s+/g, '(').replace(/\s+\)/g, ')');
    
    navigator.clipboard.writeText(raw)
        .then(() => showNotification('Copied raw!'))
        .catch(() => showNotification('Failed to copy', 'error'));
}

function clearEditor() {
    textarea.value = '';
    updateEditor();
    showNotification('Cleared!');
}

function showNotification(message, type = 'success') {
    const notification = document.getElementById('notification');
    notification.textContent = message;
    notification.className = 'notification' + (type === 'error' ? ' error' : '');
    notification.classList.add('show');
    setTimeout(() => notification.classList.remove('show'), 2500);
}

// Sidebar functions
function toggleSidebar() {
    document.getElementById('sidebar').classList.toggle('open');
    document.getElementById('sidebarOverlay').classList.toggle('show');
}

// Compiler functions
let fieldValues = {};

function extractFields(code) {
    const fieldPattern = /\[\[\s*([^\]]+?)\s*\]\]/g;
    const fields = new Set();
    let match;
    
    while ((match = fieldPattern.exec(code)) !== null) {
        fields.add(match[1].trim());
    }
    
    return Array.from(fields).sort();
}

function extractAndDisplayFields() {
    const code = textarea.value;
    const fields = extractFields(code);
    const container = document.getElementById('fieldsContainer');
    
    if (fields.length === 0) {
        container.innerHTML = '<div class="no-fields">No fields detected. Add field tokens like [[FieldName]] to your formula.</div>';
        return;
    }
    
    // Preserve existing values
    const oldValues = { ...fieldValues };
    fieldValues = {};
    
    container.innerHTML = fields.map(field => {
        const existingValue = oldValues[field] || '';
        fieldValues[field] = existingValue;
        return `
            <div class="field-item">
                <label class="field-label">[[ ${field} ]]</label>
                <input type="text" 
                       class="field-input" 
                       placeholder="Enter value..."
                       value="${escapeHtml(existingValue)}"
                       onchange="updateFieldValue('${escapeHtml(field)}', this.value)"
                       oninput="updateFieldValue('${escapeHtml(field)}', this.value)">
            </div>
        `;
    }).join('');
}

function updateFieldValue(field, value) {
    fieldValues[field] = value;
}

function compileFormula() {
    // This is a placeholder - actual compilation would happen here
    const code = textarea.value;
    let compiled = code;
    
    // Replace field tokens with their values
    for (const [field, value] of Object.entries(fieldValues)) {
        const pattern = new RegExp(`\\[\\[\\s*${escapeRegex(field)}\\s*\\]\\]`, 'g');
        compiled = compiled.replace(pattern, value || `[[${field}]]`);
    }
    
    document.getElementById('compilerOutput').textContent = compiled;
    showNotification('Formula compiled! (WIP)');
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Function documentation
// Function documentation (from official ProcessPlan documentation)
const FUNCTION_DOCS = [
    { name: '!CONTAINS', syntax: '=!CONTAINS(DoesThisValueNotExist; AnywhereInsideThisValue)', description: 'Returns true if a search text is NOT found within some other text.', example: '=!CONTAINS(SearchText; [[Field]])' },
    { name: '!EQUALS', syntax: '=!EQUALS(DoesThisValue; NotEqualThisValue; OrThisValue; ...)', description: 'Returns true if the first value does NOT equal any of the other values.', example: '=!EQUALS([[Status]]; Approved; Complete)' },
    { name: 'ANYTRUE', syntax: '=ANYTRUE(IsThisFunctionTrue; IsThisFunctionTrue; ...)', description: 'Returns 1 (true) if ANY parameter returns true. Numbers > 0 are true.', example: '=ANYTRUE(=EQUALS([[Status]]; Complete); =GTNUM([[Score]]; 80))' },
    { name: 'APPEND', syntax: '=APPEND(Separator; Item1; Item2; ...)', description: 'Combines values together with a specified separator character.', example: '[[FirstName]]=APPEND( ; [[LastName]])' },
    { name: 'BDATE', syntax: '=BDATE(IsThisDate; GreaterThanThisDate; AndLessThanThisDate)', description: 'Returns 1 if the date is between two other dates (exclusive), 0 if false.', example: '=BDATE([[DueDate]]; 2024-01-01; 2024-12-31)' },
    { name: 'BENUM', syntax: '=BENUM(IsThisNum; GreaterThanOrEqualToThisNum; AndLessThanOrEqualToThisNum)', description: 'Returns 1 if number is between or equal to two numbers (inclusive).', example: '=BENUM([[Score]]; 0; 100)' },
    { name: 'CALC', syntax: '=CALC(MathematicalExpression)', description: 'Performs mathematical operations on numbers or numeric fields.', example: '=CALC([[Price]] * [[Quantity]])' },
    { name: 'CEILING', syntax: '=CEILING(AnyNumber)', description: 'Returns the smallest integer >= the specified number.', example: '=CEILING(4.2)' },
    { name: 'CONTAINS', syntax: '=CONTAINS(DoesThisValueExist; AnywhereInsideThisValue)', description: 'Returns true if search text is found within other text.', example: '=CONTAINS(urgent; [[Description]])' },
    { name: 'DATEADD', syntax: '=DATEADD(UnitToIncrement; IncrementBy; DateToIncrement; OptionalMinDate)', description: 'Adds/subtracts time from a date. Units: minute, hour, workhour, day, weekday, week, month, year.', example: '=DATEADD(day; 30; [[StartDate]])' },
    { name: 'DATEDIFF', syntax: '=DATEDIFF(ReturnUnit; SubtractThisDate; FromThisDate)', description: 'Returns difference between two dates in specified unit.', example: '=DATEDIFF(day; [[StartDate]]; [[EndDate]])' },
    { name: 'DATELIST', syntax: '=DATELIST(StartDate; EndDate)', description: 'Generates semicolon-separated list of consecutive dates (inclusive).', example: '=DATELIST(2024-01-01; 2024-01-31)' },
    { name: 'DATEPART', syntax: '=DATEPART(DatePart; DateValue)', description: 'Extracts numeric part from date: year, weekday, yearday, monthweek, yearweek, month, day, hour, minute, second.', example: '=DATEPART(weekday; [[CreatedDate]])' },
    { name: 'DATEPATTERN', syntax: '=DATEPATTERN(DateRecurrencePattern; EndDateToGenerate; RecurrenceAnchorDate; StartFromStartDate)', description: 'Generates future dates based on recurrence pattern. Supports weekly, bi-weekly, monthly with exclusions.', example: '=DATEPATTERN(f1w d{12345}; 2024-12-31)' },
    { name: 'DATEROUND', syntax: '=DATEROUND(UnitToRoundTo; IntervalNum; DateToRound)', description: 'Rounds date/time to nearest interval. Units: minute, hour, day.', example: '=DATEROUND(hour; 1; [[Timestamp]])' },
    { name: 'DATESERIAL', syntax: '=DATESERIAL(Year; Month; Day)', description: 'Creates a date from year, month, day components.', example: '=DATESERIAL(2024; 12; 25)' },
    { name: 'DATETIMEMERGE', syntax: '=DATETIMEMERGE(DateValue; TimeValue)', description: 'Merges date and time into single date/time value.', example: '=DATETIMEMERGE([[DateField]]; [[TimeField]])' },
    { name: 'EMAILSPLIT', syntax: '=EMAILSPLIT(ReturnIndex; EmailAddressText)', description: 'Splits emails into semicolon list. Index 0 returns all.', example: '=EMAILSPLIT(0; email1@test.com, email2@test.com)' },
    { name: 'ENCLOSE', syntax: '=ENCLOSE(ValueYouWantToHide)', description: 'Hides text from rest of function. Useful for tokens with semicolons/HTML.', example: '=ENCLOSE([[FieldWithSemicolons]])' },
    { name: 'EQUALS', syntax: '=EQUALS(DoesThisValue; EqualThisValue; AndThisValue; ...)', description: 'Returns true if first value equals ALL other values.', example: '=EQUALS([[Status]]; Approved)' },
    { name: 'FIRSTVALUE', syntax: '=FIRSTVALUE(Item1; Item2; Item3; ...)', description: 'Returns first non-empty value from list.', example: '=FIRSTVALUE([[PreferredName]]; [[FirstName]]; Unknown)' },
    { name: 'FISCALMONTH', syntax: '=FISCALMONTH(FiscalYearStartMonthNumber; DateToEvaluate)', description: 'Returns fiscal month number based on fiscal year start.', example: '=FISCALMONTH(7; [[Date]])' },
    { name: 'FISCALYEAR', syntax: '=FISCALYEAR(FiscalYearStartMonthNumber; DateToEvaluate)', description: 'Returns fiscal year based on fiscal year start month.', example: '=FISCALYEAR(7; [[Date]])' },
    { name: 'FLOOR', syntax: '=FLOOR(AnyNumber)', description: 'Returns largest integer <= the specified number.', example: '=FLOOR(4.8)' },
    { name: 'FORMAT', syntax: '=FORMAT(FormatString; NumberOrDate)', description: 'Formats number/date according to format string.', example: '=FORMAT(0.00; [[Price]])' },
    { name: 'GTDATE', syntax: '=GTDATE(IsThisDate; GreaterThanThisDate)', description: 'Returns 1 if first date > second date, 0 if false.', example: '=GTDATE([[DueDate]]; [[Today]])' },
    { name: 'GTEDATE', syntax: '=GTEDATE(Date1; Date2)', description: 'Returns 1 if Date1 >= Date2, 0 if false.', example: '=GTEDATE([[EndDate]]; [[StartDate]])' },
    { name: 'GTENUM', syntax: '=GTENUM(IsThisNumber; GreaterOrEqualToThisNumber)', description: 'Returns 1 if first number >= second, 0 if false.', example: '=GTENUM([[Score]]; 70)' },
    { name: 'GTNUM', syntax: '=GTNUM(IsThisNumber; GreaterThanThisNumber)', description: 'Returns 1 if first number > second, 0 if false.', example: '=GTNUM([[Total]]; 1000)' },
    { name: 'HASVALUE', syntax: '=HASVALUE(DoesAnyValueExistHere)', description: 'Returns true if any value exists (not empty).', example: '=HASVALUE([[Comments]])' },
    { name: 'IF', syntax: '=IF(ConditionCheck; IfTrueReturnThis; AnotherCondition; IfTrueReturnThis; OptionalIfFalse)', description: 'Checks conditions, returns corresponding values. First true wins.', example: '=IF(=GTNUM([[Score]]; 70); Pass; Fail)' },
    { name: 'INSTANCECOUNT', syntax: '=INSTANCECOUNT(TableID; TableQuery)', description: 'Returns count of instances matching query.', example: '=INSTANCECOUNT(TableID; tf_id_xxx[eq]Value)' },
    { name: 'INSTANCETASKCOUNT', syntax: '=INSTANCETASKCOUNT(ProcessInstanceID; TemplateTaskID)', description: 'Returns times a task was assigned in a process instance.', example: '=INSTANCETASKCOUNT([[ProcessInstanceID]]; TaskID)' },
    { name: 'INSTANCEUPDATE', syntax: '=INSTANCEUPDATE(FieldIDToUpdate; TableIDToSearch; SearchQuery; NewFieldValue)', description: 'Updates field in processes matching query.', example: '=INSTANCEUPDATE(FieldID; TableID; Query; NewValue)' },
    { name: 'ISCONTEXT', syntax: '=ISCONTEXT(ContextIDToTest; AnotherOptionalID; ...)', description: 'Tests if formula runs in specified context (User, Group, Task, Form, etc.). Returns 1 if true.', example: '=IF(=ISCONTEXT(FormID); Atlanta; Orlando)' },
    { name: 'ISEMPTY', syntax: '=ISEMPTY(IsTheValueEmpty)', description: 'Returns true if field is empty.', example: '=ISEMPTY([[Notes]])' },
    { name: 'ISPUBLICUSER', syntax: '=ISPUBLICUSER()', description: 'Returns true if executed by non-logged-in user.', example: '=IF(=ISPUBLICUSER(); PublicContent; PrivateContent)' },
    { name: 'ISTRUE', syntax: '=ISTRUE(IsThisTrue; OptionalIsThisTrue; ...)', description: 'Returns true if ALL values are true. Numbers > 0 are true.', example: '=ISTRUE([[IsActive]]; [[IsVerified]])' },
    { name: 'JSONENCODE', syntax: '=JSONENCODE(TextParameter)', description: 'Returns text JSON encoded for use as JSON property value.', example: '=JSONENCODE([[MultilineText]])' },
    { name: 'JSONEXTRACT', syntax: '=JSONEXTRACT(AnyTextContainingJSON)', description: 'Extracts first valid JSON object/array from text.', example: '=JSONEXTRACT([[APIResponse]])' },
    { name: 'JSONFIFO', syntax: '=JSONFIFO(ExistingJsonArray; NewJsonObjectToAdd; MaximumLength)', description: 'Adds JSON object to array. If MaxLength exceeded, removes last. Use 0 for no max.', example: '=JSONFIFO([[LogArray]]; {"action":"login"}; 100)' },
    { name: 'JSONINDEX', syntax: '=JSONINDEX(IndexToRetrieve; ExistingJsonArray)', description: 'Returns element at index. Positive from start, negative from end.', example: '=JSONINDEX(1; [[JsonArray]])' },
    { name: 'JSONQUERY', syntax: '=JSONQUERY(JSONPropertyName; JSONContainingTheProperty)', description: 'Queries JSON and extracts property values. Use dot notation for nested.', example: '=JSONQUERY(data.name; [[JsonField]])' },
    { name: 'JSONREMOVE', syntax: '=JSONREMOVE(IndexToRemove; ExistingJsonArray)', description: 'Removes element at index and returns modified array.', example: '=JSONREMOVE(1; [[JsonArray]])' },
    { name: 'JSONUPDATE', syntax: '=JSONUPDATE(ExistingJsonObject; PropertyName; PropertyValue)', description: 'Adds or updates property in JSON object.', example: '=JSONUPDATE([[JsonObject]]; status; updated)' },
    { name: 'LEFT', syntax: '=LEFT(Count; Value)', description: 'Returns specified characters from start of string.', example: '=LEFT(3; [[Code]])' },
    { name: 'LEFTOF', syntax: '=LEFTOF(ReturnLeftOf; SearchInString)', description: 'Returns text left of first occurrence of characters.', example: '=LEFTOF(@; [[Email]])' },
    { name: 'LEFTOFLAST', syntax: '=LEFTOFLAST(ReturnLeftOf; SearchInString)', description: 'Returns text left of LAST occurrence.', example: '=LEFTOFLAST(/; [[FilePath]])' },
    { name: 'LENGTH', syntax: '=LENGTH(CharacterString)', description: 'Returns character count in string.', example: '=LENGTH([[Description]])' },
    { name: 'LINESPLIT', syntax: '=LINESPLIT(IndexOfSplitListToReturn; TextToSplit)', description: 'Splits multiline text into list. Index 0 returns all.', example: '=LINESPLIT(1; [[Address]])' },
    { name: 'LISTASLINES', syntax: '=LISTASLINES(SemicolonSeparatedList)', description: 'Converts list to text with each entry on separate line. Use ppcrlf for plain text.', example: '=LISTASLINES([[Items]])' },
    { name: 'LISTCOUNT', syntax: '=LISTCOUNT(Item1; Item2; ...)', description: 'Returns total items in list.', example: '=LISTCOUNT([[Tags]])' },
    { name: 'LISTDIFF', syntax: '=LISTDIFF(SemicolonSeparatedList1; SemicolonSeparatedList2)', description: 'Returns first list minus second list entries.', example: '=LISTDIFF([[AllItems]]; [[CompletedItems]])' },
    { name: 'LISTINDEX', syntax: '=LISTINDEX(ReturnIndex; SemicolonSeparatedTextList)', description: 'Returns entry at specified index.', example: '=LISTINDEX(2; [[Options]])' },
    { name: 'LISTINTERSECT', syntax: '=LISTINTERSECT(SemicolonSeparatedList1; SemicolonSeparatedList2)', description: 'Returns entries appearing in both lists.', example: '=LISTINTERSECT([[Skills]]; [[Required]])' },
    { name: 'LISTITEMAPPEND', syntax: '=LISTITEMAPPEND(AppendText; SemicolonSeparatedList)', description: 'Appends text to each list entry.', example: '=LISTITEMAPPEND(.pdf; [[Filenames]])' },
    { name: 'LISTITEMCONTAINS', syntax: '=LISTITEMCONTAINS(SearchForText; SemicolonSeparatedList)', description: 'Returns entries containing search text.', example: '=LISTITEMCONTAINS(error; [[LogEntries]])' },
    { name: 'LISTITEMENDSWITH', syntax: '=LISTITEMENDSWITH(SearchForText; SemicolonSeparatedList)', description: 'Returns entries ending with text.', example: '=LISTITEMENDSWITH(.pdf; [[Files]])' },
    { name: 'LISTITEMLEFT', syntax: '=LISTITEMLEFT(NumberOfCharsToReturn; SemicolonSeparatedList)', description: 'Returns leftmost chars from each entry.', example: '=LISTITEMLEFT(4; [[Codes]])' },
    { name: 'LISTITEMLEFTOF', syntax: '=LISTITEMLEFTOF(SearchForText; SemicolonSeparatedList)', description: 'Returns text left of search text for each entry.', example: '=LISTITEMLEFTOF(@; [[Emails]])' },
    { name: 'LISTITEMPREPEND', syntax: '=LISTITEMPREPEND(PrependText; SemicolonSeparatedList)', description: 'Prepends text to each list entry.', example: '=LISTITEMPREPEND(ID-; [[Numbers]])' },
    { name: 'LISTITEMREGEX', syntax: '=LISTITEMREGEX(RegEx; SemicolonSeparatedList)', description: 'Returns entries matching regex.', example: '=LISTITEMREGEX(.*Entry\\d; [[Items]])' },
    { name: 'LISTITEMRIGHT', syntax: '=LISTITEMRIGHT(NumberOfCharsToReturn; SemicolonSeparatedList)', description: 'Returns rightmost chars from each entry.', example: '=LISTITEMRIGHT(4; [[Files]])' },
    { name: 'LISTITEMRIGHTOF', syntax: '=LISTITEMRIGHTOF(SearchForText; SemicolonSeparatedList)', description: 'Returns text right of search text for each entry.', example: '=LISTITEMRIGHTOF(@; [[Emails]])' },
    { name: 'LISTITEMSTARTSWITH', syntax: '=LISTITEMSTARTSWITH(SearchForText; SemicolonSeparatedList)', description: 'Returns entries starting with text.', example: '=LISTITEMSTARTSWITH(A; [[Codes]])' },
    { name: 'LISTJOIN', syntax: '=LISTJOIN(NewListItemSeparator; SemicolonSeparatedList)', description: 'Joins entries with separator. Keywords: ppnewline, pptab, ppcrlf, ppsp.', example: '=LISTJOIN(ppnewline; [[Items]])' },
    { name: 'LISTMERGE', syntax: '=LISTMERGE(SemicolonSeparatedList1; SemicolonSeparatedList2)', description: 'Returns all unique entries from both lists.', example: '=LISTMERGE([[List1]]; [[List2]])' },
    { name: 'LISTUNIQUE', syntax: '=LISTUNIQUE(SemicolonSeparatedList)', description: 'Returns unique entries only (removes duplicates).', example: '=LISTUNIQUE([[AllTags]])' },
    { name: 'LOWERCASE', syntax: '=LOWERCASE(String)', description: 'Converts string to lowercase.', example: '=LOWERCASE([[Name]])' },
    { name: 'LTDATE', syntax: '=LTDATE(IsThisDate; LessThanThisDate)', description: 'Returns 1 if first date < second date, 0 if false.', example: '=LTDATE([[Created]]; [[Deadline]])' },
    { name: 'LTEDATE', syntax: '=LTEDATE(IsThisDate; LessThanOrEqualToThisDate)', description: 'Returns 1 if first date <= second date, 0 if false.', example: '=LTEDATE([[Start]]; [[End]])' },
    { name: 'LTENUM', syntax: '=LTENUM(Value1; Value2)', description: 'Returns 1 if first value <= second, 0 if false.', example: '=LTENUM([[Count]]; 10)' },
    { name: 'LTNUM', syntax: '=LTNUM(IsThisValue; LessThanThisValue)', description: 'Returns 1 if first value < second, 0 if false.', example: '=LTNUM([[Age]]; 18)' },
    { name: 'MAX', syntax: '=MAX(Parameter1; Parameter2; ...)', description: 'Returns maximum number from list.', example: '=MAX([[Score1]]; [[Score2]]; [[Score3]])' },
    { name: 'MIN', syntax: '=MIN(Parameter1; Parameter2; ...)', description: 'Returns minimum number from list.', example: '=MIN([[Price1]]; [[Price2]])' },
    { name: 'MONTH', syntax: '=MONTH(DateValue)', description: 'Extracts month (1-12) from date.', example: '=MONTH([[CreatedDate]])' },
    { name: 'MONTHDAY', syntax: '=MONTHDAY(DateValue)', description: 'Extracts day of month (1-31) from date.', example: '=MONTHDAY([[Birthday]])' },
    { name: 'MONTHLASTDAY', syntax: '=MONTHLASTDAY(DateValue; OptionalAddOrSubtractDay)', description: 'Returns last day of month. Optional param adds/subtracts days.', example: '=MONTHLASTDAY([[InvoiceDate]]; -1)' },
    { name: 'NORMALIZETEXT', syntax: '=NORMALIZETEXT(TextValue)', description: 'Removes spaces, formatting, HTML, carriage returns, line feeds.', example: '=NORMALIZETEXT([[Input]])' },
    { name: 'NOT', syntax: '=NOT(BooleanParameter)', description: 'Returns opposite of Boolean (True->False). Zero is false.', example: '=NOT(=ISEMPTY([[Field]]))' },
    { name: 'NUM', syntax: '=NUM(Parameter)', description: 'Extracts number by stripping non-numeric chars.', example: '=NUM([[PriceText]])' },
    { name: 'NUMSPLIT', syntax: '=NUMSPLIT(Parameter)', description: 'Extracts all numbers as semicolon list.', example: '=NUMSPLIT(123 Sample St, NY 10016)' },
    { name: 'PARSE', syntax: '=PARSE(GetRightOfThisText; GetLeftOfThisText; SearchWithinThisText)', description: 'Returns text between two markers. Special: crlf, tab.', example: '=PARSE(Name:; Age:; [[Data]])' },
    { name: 'PARTITION', syntax: '=PARTITION(NumberToBePartitioned; Divisor)', description: 'Returns list of integers summing to original number.', example: '=PARTITION(100; 31)' },
    { name: 'RANDOMNUM', syntax: '=RANDOMNUM(MinimumNumber; MaximumNumber)', description: 'Returns random number between bounds.', example: '=RANDOMNUM(1; 100)' },
    { name: 'REGEXFIND', syntax: '=REGEXFIND(RegEx; StringToSearch)', description: 'Returns text matching regex pattern.', example: '=REGEXFIND(\\d+; This has number: 263)' },
    { name: 'REGEXWORDSONLY', syntax: '=REGEXWORDSONLY(TextToConvertToRegex)', description: 'Converts text to regex matching words only, ignoring punctuation.', example: '=REGEXWORDSONLY([[SearchText]])' },
    { name: 'REMOVECHARS', syntax: '=REMOVECHARS(Value; CharsToRemove)', description: 'Removes specified characters from text.', example: '=REMOVECHARS([[Phone]]; -() )' },
    { name: 'REMOVEDIACRITICS', syntax: '=REMOVEDIACRITICS(Value)', description: 'Removes accents, replacing with equivalent chars.', example: '=REMOVEDIACRITICS(cafe)' },
    { name: 'REMOVESPACES', syntax: '=REMOVESPACES(Value)', description: 'Removes all spaces from text.', example: '=REMOVESPACES([[Code]])' },
    { name: 'REMOVESYMBOLS', syntax: '=REMOVESYMBOLS(Value)', description: 'Removes symbols, keeping alphanumeric and spaces.', example: '=REMOVESYMBOLS([[Input]])' },
    { name: 'REPLACE', syntax: '=REPLACE(SearchForText; NewText; SearchWithinText)', description: 'Finds and replaces text.', example: '=REPLACE(old; new; [[Text]])' },
    { name: 'RIGHT', syntax: '=RIGHT(Count; Value)', description: 'Returns specified chars from end of string.', example: '=RIGHT(4; [[Filename]])' },
    { name: 'RIGHTOF', syntax: '=RIGHTOF(ReturnRightOf; SearchInString)', description: 'Returns text right of first occurrence.', example: '=RIGHTOF(@; [[Email]])' },
    { name: 'RIGHTOFLAST', syntax: '=RIGHTOFLAST(ReturnRightOf; SearchInString)', description: 'Returns text right of LAST occurrence.', example: '=RIGHTOFLAST(/; [[FilePath]])' },
    { name: 'ROUND', syntax: '=ROUND(NumOfDecimals; AnyNumber)', description: 'Rounds to specified decimal places.', example: '=ROUND(2; [[Total]])' },
    { name: 'SPLIT', syntax: '=SPLIT(CharacterToSplitOn; IndexOfSplitToReturn; TextToSplit)', description: 'Splits on character, returns section. Index 0 returns all.', example: '=SPLIT(-; 2; [[Code]])' },
    { name: 'SUM', syntax: '=SUM(Parameter1; Parameter2; ...)', description: 'Sums list of numbers.', example: '=SUM([[Item1]]; [[Item2]]; [[Item3]])' },
    { name: 'TABLEAVG', syntax: '=TABLEAVG(FieldID; TableID; TableQuery)', description: 'Returns average of column values in table.', example: '=TABLEAVG(FieldID; TableID; Query)' },
    { name: 'TABLEJSON', syntax: '=TABLEJSON(NumberOfColumns; ProcessTableID; OptionalTableQuery)', description: 'Returns table data as JSON array of objects.', example: '=TABLEJSON(5; TableID; Query)' },
    { name: 'TABLELOOKUP', syntax: '=TABLELOOKUP(FieldTokenToRetrieve; TableID; TableQuery)', description: 'Returns value from Process Table matching query.', example: '=TABLELOOKUP([[FieldToken]]; TableID; Query)' },
    { name: 'TABLESUM', syntax: '=TABLESUM(FieldID; TableID; TableQuery)', description: 'Sums column values in table.', example: '=TABLESUM(FieldID; TableID; Query)' },
    { name: 'TASKLOOKUP', syntax: '=TASKLOOKUP(FieldTokenToRetrieve; TemplateTaskID; TaskQuery)', description: 'Queries task and returns requested attribute.', example: '=TASKLOOKUP([[AssignedTo]]; TaskID; Query)' },
    { name: 'TASKREPORT', syntax: '=TASKREPORT(TextBlockID; ProcessInstanceID; IncludeSubprocessTask; FilterQuery)', description: 'Produces task report using Text Block format. Use 0 for ProcessInstanceID to query all.', example: '=TASKREPORT([[TextBlockID]]; [[ProcessInstanceID]]; true; it_name[ct]task)' },
    { name: 'TITLECASE', syntax: '=TITLECASE(TextParameter)', description: 'Capitalizes first letter of each word.', example: '=TITLECASE([[name]])' },
    { name: 'TRIM', syntax: '=TRIM(TextToTrim)', description: 'Removes leading/trailing spaces and double spaces.', example: '=TRIM([[Input]])' },
    { name: 'UPPERCASE', syntax: '=UPPERCASE(String)', description: 'Capitalizes each letter.', example: '=UPPERCASE([[Code]])' },
    { name: 'URLENCODE', syntax: '=URLENCODE(CharacterToEncode)', description: 'Encodes characters for URL use.', example: '=URLENCODE([[SearchTerm]])' },
    { name: 'WORDSPLIT', syntax: '=WORDSPLIT(ReturnWordIndex; PlainText)', description: 'Splits text into word list. Index 0 returns all.', example: '=WORDSPLIT(1; [[FullName]])' },
    { name: 'WORKDAY', syntax: '=WORKDAY(WorkScheduleID; WorkdaysToSkip; DateToStartEvaluatingFrom)', description: 'Advances date to next working day based on work schedule.', example: '=WORKDAY([[WorkScheduleID]]; 5; [[StartDate]])' },
    { name: 'YEAR', syntax: '=YEAR(DateValue)', description: 'Extracts year from date.', example: '=YEAR([[CreatedDate]])' }
];

function renderFunctions(functions) {
    const container = document.getElementById('functionList');
    container.innerHTML = functions.map(func => `
        <div class="function-item" data-name="${func.name}">
            <div class="function-header" onclick="toggleFunction(this)">
                <span class="function-name">=${func.name}()</span>
                <span class="function-arrow">â–¼</span>
            </div>
            <div class="function-details">
                <div class="function-syntax">${escapeHtml(func.syntax)}</div>
                <div class="function-description">${func.description}</div>
                <div class="function-example">
                    <div class="function-example-label">Example</div>
                    <div class="function-example-code">${escapeHtml(func.example)}</div>
                </div>
            </div>
        </div>
    `).join('');
}

function toggleFunction(header) {
    header.parentElement.classList.toggle('open');
}

function filterFunctions() {
    const search = document.getElementById('functionSearch').value.toLowerCase();
    const filtered = FUNCTION_DOCS.filter(func => 
        func.name.toLowerCase().includes(search) || 
        func.description.toLowerCase().includes(search)
    );
    renderFunctions(filtered);
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    renderFunctions(FUNCTION_DOCS);
    updateEditor();
});
</script>
</body>
</html>
