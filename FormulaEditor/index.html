<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Formula Editor</title>
<link rel="icon" type="image/png" href="faviconV2.png">
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
        /* Dark theme (default) */
        --bg-primary: #191919;
        --bg-secondary: #232323;
        --bg-tertiary: #1a1a1a;
        --bg-hover: #2a2a2a;
        --border-color: #333;
        --border-light: #404040;
        --text-primary: #e0e0e0;
        --text-secondary: #888;
        --text-muted: #666;
        --text-dim: #555;
        --accent-blue: #3b82f6;
        --accent-blue-hover: #2563eb;
        --accent-green: #22c55e;
        --accent-green-hover: #16a34a;
        --accent-red: #ef4444;
        --syntax-function: #4ade80;
        --syntax-string: #f97316;
        --syntax-number: #60a5fa;
        --syntax-bracket: #a78bfa;
        --scrollbar-thumb: #444;
        --scrollbar-thumb-hover: #555;
        --line-numbers-bg: #1e1e1e;
    }

    body.light-mode {
        --bg-primary: #f5f5f5;
        --bg-secondary: #ffffff;
        --bg-tertiary: #fafafa;
        --bg-hover: #e8e8e8;
        --border-color: #ddd;
        --border-light: #ccc;
        --text-primary: #1a1a1a;
        --text-secondary: #555;
        --text-muted: #777;
        --text-dim: #999;
        --accent-blue: #2563eb;
        --accent-blue-hover: #1d4ed8;
        --accent-green: #16a34a;
        --accent-green-hover: #15803d;
        --accent-red: #dc2626;
        --syntax-function: #16a34a;
        --syntax-string: #ea580c;
        --syntax-number: #2563eb;
        --syntax-bracket: #7c3aed;
        --scrollbar-thumb: #ccc;
        --scrollbar-thumb-hover: #aaa;
        --line-numbers-bg: #eee;
    }

    body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; 
        background: var(--bg-primary); 
        color: var(--text-primary);
        min-height: 100vh;
        transition: background 0.3s, color 0.3s;
    }

    /* Header */
    .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 24px;
        border-bottom: 1px solid var(--border-color);
        background: var(--bg-primary);
    }

    .header-left {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .status-dot {
        width: 10px;
        height: 10px;
        background: var(--accent-blue);
        border-radius: 50%;
    }

    .header-title {
        font-size: 15px;
        font-weight: 500;
        color: var(--text-primary);
    }

    .toggle-sidebar-btn {
        background: var(--accent-blue);
        border: none;
        color: white;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .toggle-sidebar-btn:hover {
        background: var(--accent-blue-hover);
    }

    /* Main Content */
    .main-content {
        max-width: 1100px;
        margin: 0 auto;
        padding: 32px 24px;
    }

    /* Editor Card */
    .editor-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        overflow: hidden;
    }

    .editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid var(--border-color);
    }

    .editor-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
    }

    .editor-actions {
        display: flex;
        gap: 8px;
    }

    .btn {
        padding: 8px 16px;
        font-size: 13px;
        font-weight: 500;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
    }

    .btn-primary {
        background: var(--accent-blue);
        color: white;
    }

    .btn-primary:hover {
        background: var(--accent-blue-hover);
    }

    .btn-secondary {
        background: var(--bg-hover);
        color: var(--text-primary);
        border: 1px solid var(--border-light);
    }

    .btn-secondary:hover {
        background: var(--border-color);
    }

    /* Code Editor */
    .code-editor {
        display: flex;
        min-height: 500px;
        max-height: 70vh;
        overflow: hidden;
        background: var(--bg-tertiary);
    }

    .line-numbers-wrapper {
        background: var(--line-numbers-bg);
        border-right: 1px solid var(--border-color);
        min-width: 50px;
        overflow: hidden;
    }

    .line-numbers {
        padding: 16px 0;
        text-align: right;
        user-select: none;
    }

    .line-number {
        padding: 0 12px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        line-height: 1.6;
        color: var(--text-dim);
    }

    .line-number.active {
        color: var(--text-secondary);
    }

    .code-area {
        flex: 1;
        position: relative;
        overflow: hidden;
    }

    .code-textarea {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        padding: 16px;
        background: transparent;
        border: none;
        color: transparent;
        caret-color: var(--text-primary);
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        line-height: 1.6;
        resize: none;
        white-space: pre;
        overflow: auto;
        z-index: 2;
        tab-size: 3;
        -moz-tab-size: 3;
    }

    .code-textarea:focus {
        outline: none;
    }

    /* Fix text selection visibility */
    .code-textarea::selection {
        background: rgba(59, 130, 246, 0.3);
        color: transparent;
    }

    .code-textarea::-moz-selection {
        background: rgba(59, 130, 246, 0.3);
        color: transparent;
    }

    .code-highlight {
        position: absolute;
        top: 0;
        left: 0;
        padding: 16px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        line-height: 1.6;
        white-space: pre;
        pointer-events: none;
        min-height: 100%;
        min-width: 100%;
        z-index: 1;
        tab-size: 3;
        -moz-tab-size: 3;
    }

    /* Scrollbar */
    .code-editor::-webkit-scrollbar,
    .code-textarea::-webkit-scrollbar {
        width: 12px;
        height: 12px;
    }

    .code-editor::-webkit-scrollbar-track,
    .code-textarea::-webkit-scrollbar-track {
        background: var(--bg-tertiary);
    }

    .code-editor::-webkit-scrollbar-thumb,
    .code-textarea::-webkit-scrollbar-thumb {
        background: var(--scrollbar-thumb);
        border-radius: 6px;
        border: 2px solid var(--bg-tertiary);
    }

    .code-editor::-webkit-scrollbar-thumb:hover,
    .code-textarea::-webkit-scrollbar-thumb:hover {
        background: var(--scrollbar-thumb-hover);
    }

    .code-editor::-webkit-scrollbar-corner {
        background: var(--bg-tertiary);
    }

    /* Syntax Highlighting */
    .function { color: var(--syntax-function); font-weight: 500; }
    .string { color: var(--syntax-string); }
    .number { color: var(--syntax-number); }
    .operator { color: var(--text-primary); }
    .parenthesis { color: var(--text-secondary); }
    .bracket { color: var(--syntax-bracket); }
    .comment { color: var(--text-muted); font-style: italic; }

    /* Notification */
    .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        background: var(--accent-green);
        color: white;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.3s;
        pointer-events: none;
        z-index: 1001;
    }

    .notification.show {
        opacity: 1;
        transform: translateY(0);
    }

    .notification.error {
        background: var(--accent-red);
    }

    /* Left Sidebar - Saved Formulas */
    .left-sidebar {
        position: fixed;
        top: 0;
        left: -320px;
        width: 320px;
        height: 100vh;
        background: var(--bg-secondary);
        border-right: 1px solid var(--border-color);
        transition: left 0.3s ease;
        z-index: 1000;
        display: flex;
        flex-direction: column;
    }

    .left-sidebar.open {
        left: 0;
    }

    .left-sidebar-header {
        padding: 16px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .left-sidebar-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
    }

    .left-sidebar-close {
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
    }

    .left-sidebar-close:hover {
        color: var(--text-primary);
    }

    .save-section {
        padding: 16px 20px;
        border-bottom: 1px solid var(--border-color);
    }

    .save-input-group {
        display: flex;
        gap: 8px;
        margin-bottom: 0;
    }

    .save-input {
        flex: 1;
        padding: 10px 12px;
        background: var(--bg-primary);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text-primary);
        font-size: 14px;
    }

    .save-input:focus {
        outline: none;
        border-color: var(--accent-blue);
    }

    .save-input::placeholder {
        color: var(--text-muted);
    }

    .save-btn {
        padding: 10px 16px;
        background: var(--accent-green);
        border: none;
        border-radius: 6px;
        color: white;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        white-space: nowrap;
    }

    .save-btn:hover {
        background: var(--accent-green-hover);
    }

    .formulas-list-header {
        padding: 12px 20px;
        font-size: 12px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .import-export-btns {
        display: flex;
        gap: 4px;
    }

    .icon-btn {
        background: none;
        border: 1px solid var(--scrollbar-thumb);
        border-radius: 4px;
        padding: 6px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-secondary);
    }

    .icon-btn:hover {
        background: var(--border-color);
        border-color: var(--scrollbar-thumb-hover);
        color: var(--text-primary);
    }

    .icon-btn svg {
        display: block;
    }

    .formulas-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px 0;
    }

    .formula-item {
        padding: 12px 20px;
        border-bottom: 1px solid var(--bg-hover);
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background 0.2s;
    }

    .formula-item:hover {
        background: var(--bg-hover);
    }

    .formula-item-info {
        flex: 1;
        min-width: 0;
    }

    .formula-item-name {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .formula-item-date {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: 4px;
    }

    .formula-item-actions {
        display: flex;
        gap: 4px;
        opacity: 0;
        transition: opacity 0.2s;
    }

    .formula-item:hover .formula-item-actions {
        opacity: 1;
    }

    .formula-action-btn {
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 16px;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        transition: all 0.2s;
    }

    .formula-action-btn:hover {
        background: var(--border-color);
        color: var(--text-primary);
    }

    .formula-action-btn.delete:hover {
        background: var(--accent-red);
        color: #fff;
    }

    .no-formulas {
        padding: 40px 20px;
        text-align: center;
        color: var(--text-muted);
        font-size: 14px;
    }

    .no-formulas-icon {
        font-size: 32px;
        margin-bottom: 12px;
        opacity: 0.5;
    }

    .left-sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
        z-index: 999;
    }

    .left-sidebar-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    .toggle-formulas-btn {
        background: var(--accent-green);
        border: none;
        color: white;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        margin-right: 8px;
    }

    .toggle-formulas-btn:hover {
        background: var(--accent-green-hover);
    }

    .header-buttons {
        display: flex;
        align-items: center;
    }

    .theme-toggle-btn {
        background: none;
        border: 1px solid var(--border-light);
        border-radius: 6px;
        padding: 8px 12px;
        cursor: pointer;
        margin-right: 8px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .theme-toggle-btn:hover {
        background: var(--bg-hover);
        border-color: var(--scrollbar-thumb-hover);
    }

    .theme-icon {
        font-size: 16px;
    }

    /* Help Button */
    .help-btn {
        background: none;
        border: 1px solid var(--border-light);
        border-radius: 50%;
        width: 32px;
        height: 32px;
        cursor: pointer;
        margin-right: 8px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 14px;
        color: var(--text-secondary);
    }

    .help-btn:hover {
        background: var(--bg-hover);
        border-color: var(--scrollbar-thumb-hover);
        color: var(--text-primary);
    }

    /* Help Modal */
    .help-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
        z-index: 2000;
    }

    .help-modal-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    .help-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        overflow: hidden;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
        z-index: 2001;
        display: flex;
        flex-direction: column;
    }

    .help-modal.show {
        opacity: 1;
        visibility: visible;
        transform: translate(-50%, -50%) scale(1);
    }

    .help-modal-header {
        padding: 20px 24px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .help-modal-header h2 {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
    }

    .help-modal-close {
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 28px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
        transition: color 0.2s;
    }

    .help-modal-close:hover {
        color: var(--text-primary);
    }

    .help-modal-content {
        padding: 24px;
        overflow-y: auto;
        flex: 1;
    }

    .help-section {
        margin-bottom: 24px;
    }

    .help-section:last-child {
        margin-bottom: 0;
    }

    .help-section h3 {
        font-size: 14px;
        font-weight: 600;
        color: var(--syntax-function);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 12px;
    }

    .help-section p {
        color: var(--text-secondary);
        line-height: 1.6;
        margin: 0;
    }

    .help-features-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .help-features-list li {
        position: relative;
        padding-left: 20px;
        margin-bottom: 16px;
    }

    .help-features-list li:last-child {
        margin-bottom: 0;
    }

    .help-features-list li::before {
        content: '‚Ä¢';
        position: absolute;
        left: 0;
        top: 0;
        color: var(--syntax-function);
        font-size: 18px;
        line-height: 1.2;
    }

    .help-features-list strong {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-primary);
        display: block;
        margin-bottom: 4px;
    }

    .help-features-list p {
        font-size: 13px;
        margin: 0;
        color: var(--text-secondary);
    }

    .help-shortcuts {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .shortcut {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 13px;
    }

    .shortcut kbd {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 4px 8px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: var(--text-primary);
        min-width: 80px;
        text-align: center;
    }

    .shortcut span {
        color: var(--text-secondary);
    }

    .help-tips {
        list-style: none;
        margin: 0;
        padding: 0;
        color: var(--text-secondary);
        line-height: 1.8;
        font-size: 13px;
    }

    .help-tips li {
        position: relative;
        padding-left: 20px;
    }

    .help-tips li::before {
        content: '‚Ä¢';
        position: absolute;
        left: 0;
        color: var(--syntax-function);
        font-size: 18px;
    }

    .help-tips code {
        background: var(--bg-tertiary);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: var(--syntax-bracket);
    }

    .help-modal-content code {
        background: var(--bg-tertiary);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: var(--syntax-function);
    }

    .help-modal-content kbd {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 2px 6px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 11px;
        color: var(--text-primary);
    }

    /* Sidebar */
    .sidebar {
        position: fixed;
        top: 0;
        right: -350px;
        width: 350px;
        height: 100vh;
        background: var(--bg-secondary);
        border-left: 1px solid var(--border-color);
        transition: right 0.3s ease;
        z-index: 1000;
        display: flex;
        flex-direction: column;
    }

    .sidebar.open {
        right: 0;
    }

    .sidebar-header {
        padding: 16px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .sidebar-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
    }

    .sidebar-close {
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
    }

    .sidebar-close:hover {
        color: var(--text-primary);
    }

    .sidebar-search {
        padding: 12px 20px;
        border-bottom: 1px solid var(--border-color);
    }

    .sidebar-search input {
        width: 100%;
        padding: 10px 12px;
        background: var(--bg-primary);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text-primary);
        font-size: 14px;
    }

    .sidebar-search input:focus {
        outline: none;
        border-color: var(--accent-blue);
    }

    .sidebar-search input::placeholder {
        color: var(--text-muted);
    }

    .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 8px 0;
    }

    .function-item {
        border-bottom: 1px solid var(--bg-hover);
    }

    .function-header {
        padding: 12px 20px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background 0.2s;
    }

    .function-header:hover {
        background: var(--bg-hover);
    }

    .function-name {
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        color: var(--syntax-function);
        font-weight: 500;
    }

    .function-arrow {
        color: var(--text-muted);
        transition: transform 0.2s;
        font-size: 12px;
    }

    .function-item.open .function-arrow {
        transform: rotate(180deg);
    }

    .function-details {
        display: none;
        padding: 0 20px 16px 20px;
        background: var(--bg-tertiary);
    }

    .function-item.open .function-details {
        display: block;
    }

    .function-syntax {
        background: var(--bg-primary);
        padding: 10px 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: var(--syntax-string);
        border: 1px solid var(--border-color);
    }

    .function-description {
        font-size: 13px;
        color: var(--text-secondary);
        line-height: 1.5;
    }

    .function-example {
        margin-top: 10px;
        padding: 10px 12px;
        background: var(--bg-primary);
        border-radius: 6px;
        border: 1px solid var(--border-color);
    }

    .function-example-label {
        font-size: 11px;
        color: var(--text-muted);
        text-transform: uppercase;
        margin-bottom: 6px;
    }

    .function-example-code {
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: var(--text-primary);
    }

    .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
        z-index: 999;
    }

    .sidebar-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    /* Autocomplete Dropdown */
    .autocomplete-dropdown {
        position: absolute;
        background: var(--bg-hover);
        border: 1px solid var(--scrollbar-thumb);
        border-radius: 6px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 100;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        min-width: 200px;
    }

    .autocomplete-dropdown.show {
        display: block;
    }

    .autocomplete-item {
        padding: 8px 12px;
        cursor: pointer;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        color: var(--syntax-function);
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
        background: var(--accent-blue);
        color: white;
    }

    .autocomplete-dropdown::-webkit-scrollbar {
        width: 8px;
    }

    .autocomplete-dropdown::-webkit-scrollbar-track {
        background: var(--bg-hover);
    }

    .autocomplete-dropdown::-webkit-scrollbar-thumb {
        background: var(--scrollbar-thumb-hover);
        border-radius: 4px;
    }

    /* Parameter Hint - below editor */
    .parameter-hint {
        background: var(--bg-hover);
        border: 1px solid var(--scrollbar-thumb-hover);
        border-radius: 0 0 8px 8px;
        border-top: none;
        padding: 8px 16px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: var(--text-primary);
        display: none;
        margin-top: -1px;
    }

    .parameter-hint.show {
        display: block;
    }

    .parameter-hint .hint-line {
        white-space: pre;
        line-height: 1.6;
    }

    .parameter-hint .hint-line:not(:last-child) .param:not(.active),
    .parameter-hint .hint-line:not(:last-child) .function-name {
        opacity: 0.5;
    }

    .parameter-hint .param {
        color: var(--text-secondary);
    }

    .parameter-hint .param.active {
        color: var(--syntax-function);
        font-weight: 600;
    }

    .parameter-hint .function-name {
        color: var(--syntax-function);
    }

    /* Compiler Section */
    .compiler-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        overflow: hidden;
        margin-top: 24px;
        position: relative;
    }

    .compiler-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid var(--border-color);
    }

    .compiler-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
    }

    .compiler-content {
        padding: 20px;
    }

    .compiler-warning {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        background: rgba(249, 115, 22, 0.1);
        border: 1px solid rgba(249, 115, 22, 0.3);
        border-radius: 6px;
        margin-bottom: 16px;
        font-size: 13px;
        color: var(--syntax-string);
    }

    .compiler-warning .warning-icon {
        font-size: 14px;
    }

    .fields-section {
        margin-bottom: 20px;
    }

    .fields-title {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .fields-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 12px;
    }

    .field-item {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .field-label {
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 12px;
        color: var(--syntax-bracket);
        font-weight: 500;
    }

    .field-input {
        padding: 10px 12px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text-primary);
        font-size: 14px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
    }

    .field-input:focus {
        outline: none;
        border-color: var(--accent-blue);
    }

    .field-input::placeholder {
        color: var(--text-dim);
    }

    .no-fields {
        color: var(--text-muted);
        font-size: 14px;
        font-style: italic;
        padding: 20px;
        text-align: center;
        background: var(--bg-tertiary);
        border-radius: 8px;
    }

    .output-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid var(--border-color);
    }

    .output-title {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .output-box {
        padding: 16px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 13px;
        color: var(--text-primary);
        min-height: 60px;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .output-box.error {
        border-color: var(--accent-red);
        color: var(--accent-red);
    }

    .output-box.success {
        border-color: var(--accent-green);
    }

    /* Function Status Section */
    .function-status-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid var(--border-color);
    }

    .function-status-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
    }

    .function-status-title {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .function-status-toggle {
        background: none;
        border: 1px solid var(--border-light);
        border-radius: 4px;
        padding: 4px 10px;
        font-size: 12px;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s;
    }

    .function-status-toggle:hover {
        background: var(--bg-hover);
        color: var(--text-primary);
    }

    .function-status-container {
        display: none;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 16px;
        max-height: 300px;
        overflow-y: auto;
    }

    .function-status-container.show {
        display: block;
    }

    .function-status-summary {
        display: flex;
        gap: 16px;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid var(--border-color);
    }

    .status-count {
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .status-count.implemented {
        color: var(--accent-green);
    }

    .status-count.partial {
        color: var(--syntax-string);
    }

    .status-count.not-implemented {
        color: var(--text-muted);
    }

    .function-status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 8px;
    }

    .function-status-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 4px;
        background: var(--bg-secondary);
    }

    .function-status-item.implemented {
        color: var(--accent-green);
    }

    .function-status-item.partial {
        color: var(--syntax-string);
    }

    .function-status-item.not-implemented {
        color: var(--text-muted);
    }

    .status-icon {
        font-size: 10px;
    }

    .wip-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(25, 25, 25, 0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        backdrop-filter: blur(2px);
    }

    .wip-badge {
        background: linear-gradient(135deg, #f97316, #ea580c);
        color: white;
        padding: 12px 32px;
        border-radius: 8px;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 2px;
        text-transform: uppercase;
        box-shadow: 0 4px 20px rgba(249, 115, 22, 0.4);
        margin-bottom: 12px;
    }

    .wip-text {
        color: #888;
        font-size: 14px;
    }

    @media (max-width: 768px) {
        .sidebar {
            width: 100%;
            right: -100%;
        }
        .editor-header {
            flex-direction: column;
            gap: 12px;
            align-items: flex-start;
        }
        .editor-actions {
            width: 100%;
            flex-wrap: wrap;
        }
        .btn {
            flex: 1;
            min-width: 120px;
        }
    }
</style>
</head>
<body>

<!-- Header -->
<div class="header">
    <div class="header-left">
        <div class="status-dot"></div>
        <span class="header-title"><a href="../" style="color: inherit; text-decoration: none;">ProcessPlan Tools</a> | Formula Editor</span>
    </div>
    <div class="header-buttons">
        <button class="help-btn" onclick="toggleHelpModal()" title="Help">
            <span>?</span>
        </button>
        <button class="theme-toggle-btn" onclick="toggleTheme()" title="Toggle light/dark mode">
            <span class="theme-icon">üåô</span>
        </button>
        <button class="toggle-formulas-btn" onclick="toggleFormulasSidebar()">
            <span>üíæ</span> View Saved Formulas
        </button>
        <button class="toggle-sidebar-btn" onclick="toggleSidebar()">
            <span>üìö</span> Functions
        </button>
    </div>
</div>

<!-- Help Modal -->
<div class="help-modal-overlay" id="helpModalOverlay" onclick="toggleHelpModal()"></div>
<div class="help-modal" id="helpModal">
    <div class="help-modal-header">
        <h2>Formula Editor Help</h2>
        <button class="help-modal-close" onclick="toggleHelpModal()">√ó</button>
    </div>
    <div class="help-modal-content">
        <section class="help-section">
            <h3>What is this?</h3>
            <p>The Formula Editor is a tool for writing and editing ProcessPlan formulas with syntax highlighting, auto-completion, and formatting.</p>
        </section>
        
        <section class="help-section">
            <h3>Features</h3>
            <ul class="help-features-list">
                <li>
                    <strong>Syntax Highlighting</strong>
                    <p>Functions, strings, numbers, and field tokens are color-coded for easy reading.</p>
                </li>
                <li>
                    <strong>Auto-Complete</strong>
                    <p>Type <code>=</code> followed by letters to see matching functions. Press <kbd>Tab</kbd> or <kbd>Enter</kbd> to insert the complete function structure.</p>
                </li>
                <li>
                    <strong>Parameter Hints</strong>
                    <p>When inside a function, see parameter names below the editor. The current parameter is highlighted. Works with nested functions too!</p>
                </li>
                <li>
                    <strong>Auto-Formatting</strong>
                    <p>Paste any formula and it will be automatically formatted with proper indentation.</p>
                </li>
                <li>
                    <strong>Comments</strong>
                    <p>Add notes with <code># your comment</code>. Comments are automatically removed when copying the formula.</p>
                </li>
                <li>
                    <strong>Save Formulas</strong>
                    <p>Save formulas locally for quick access later. Import/export to share or backup.</p>
                </li>
                <li>
                    <strong>Function Reference</strong>
                    <p>Click "Functions" to browse all available ProcessPlan functions with descriptions and examples.</p>
                </li>
            </ul>
        </section>
        
        <section class="help-section">
            <h3>Keyboard Shortcuts</h3>
            <div class="help-shortcuts">
                <div class="shortcut"><kbd>Tab</kbd> <span>Insert 2 spaces / Indent selection / Accept autocomplete</span></div>
                <div class="shortcut"><kbd>Shift+Tab</kbd> <span>Unindent selection</span></div>
                <div class="shortcut"><kbd>Enter</kbd> <span>New line with auto-indent</span></div>
                <div class="shortcut"><kbd>Ctrl/Cmd+Z</kbd> <span>Undo</span></div>
                <div class="shortcut"><kbd>Ctrl/Cmd+Y</kbd> <span>Redo</span></div>
                <div class="shortcut"><kbd>Esc</kbd> <span>Close autocomplete</span></div>
            </div>
        </section>
        
        <section class="help-section">
            <h3>Tips</h3>
            <ul class="help-tips">
                <li>Use <code>[[Field Name]]</code> syntax for field tokens</li>
                <li>Add comments with <code>#</code> to document your formulas</li>
                <li>Copy Formatted keeps indentation, Copy Raw removes it (both strip comments)</li>
                <li>The compiler section is currently non-functioning.</li>
            </ul>
        </section>
    </div>
</div>

<!-- Left Sidebar Overlay -->
<div class="left-sidebar-overlay" id="leftSidebarOverlay" onclick="toggleFormulasSidebar()"></div>

<!-- Left Sidebar - Saved Formulas -->
<div class="left-sidebar" id="leftSidebar">
    <div class="left-sidebar-header">
        <span class="left-sidebar-title">Saved Formulas</span>
        <button class="left-sidebar-close" onclick="toggleFormulasSidebar()">√ó</button>
    </div>
    <div class="save-section">
        <div class="save-input-group">
            <input type="text" class="save-input" id="formulaNameInput" placeholder="Formula name..." onkeydown="if(event.key === 'Enter') saveFormula()">
            <button class="save-btn" onclick="saveFormula()">Save</button>
        </div>
    </div>
    <div class="formulas-list-header">
        <span>Your Formulas</span>
        <div class="import-export-btns">
            <button class="icon-btn" onclick="exportFormulas()" title="Export all formulas">
                <svg width="16" height="16" viewBox="0 0 512 512" fill="currentColor">
                    <path d="M256 48l-128 128h96v176h64V176h96L256 48z M416 352v96H96v-96H32v128c0 17.7 14.3 32 32 32h384c17.7 0 32-14.3 32-32V352h-64z"/>
                </svg>
            </button>
            <button class="icon-btn" onclick="document.getElementById('importFile').click()" title="Import formulas">
                <svg width="16" height="16" viewBox="0 0 512 512" fill="currentColor">
                    <path d="M256 352l128-128h-96V48h-64v176h-96l128 128z M416 352v96H96v-96H32v128c0 17.7 14.3 32 32 32h384c17.7 0 32-14.3 32-32V352h-64z"/>
                </svg>
            </button>
            <input type="file" id="importFile" accept=".json" style="display: none" onchange="importFormulas(event)">
        </div>
    </div>
    <div class="formulas-list" id="formulasList">
        <div class="no-formulas">
            <div class="no-formulas-icon">üìÅ</div>
            <div>No saved formulas yet</div>
        </div>
    </div>
</div>

<!-- Sidebar Overlay -->
<div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>

<!-- Sidebar -->
<div class="sidebar" id="sidebar">
    <div class="sidebar-header">
        <span class="sidebar-title">Function Reference</span>
        <button class="sidebar-close" onclick="toggleSidebar()">√ó</button>
    </div>
    <div class="sidebar-search">
        <input type="text" id="functionSearch" placeholder="Search functions..." oninput="filterFunctions()">
    </div>
    <div class="sidebar-content" id="functionList">
    </div>
</div>

<!-- Main Content -->
<div class="main-content">
    <div class="editor-card">
        <div class="editor-header">
            <span class="editor-title">Formula Editor</span>
            <div class="editor-actions">
                <button class="btn btn-secondary" onclick="copyFormatted()">Copy Formatted</button>
                <button class="btn btn-secondary" onclick="copyRaw()">Copy Raw</button>
                <button class="btn btn-secondary" onclick="clearEditor()">Clear</button>
            </div>
        </div>
        <div class="code-editor" id="codeEditor">
            <div class="line-numbers-wrapper">
                <div class="line-numbers" id="lineNumbers"></div>
            </div>
            <div class="code-area">
                <div class="code-highlight" id="codeHighlight"></div>
                <textarea class="code-textarea" id="codeTextarea" placeholder="Paste or type your formula here..." spellcheck="false"></textarea>
                <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
            </div>
        </div>
        <div class="parameter-hint" id="parameterHint"></div>
    </div>

    <!-- Compiler Section -->
    <div class="compiler-card">
        <div class="compiler-header">
            <span class="compiler-title">Formula Compiler</span>
            <button class="btn btn-primary" onclick="compileFormula()">Compile</button>
        </div>
        <div class="compiler-content">
            <div class="compiler-warning">
                <span class="warning-icon">‚ö†Ô∏è</span>
                <span>For testing purposes only. Outputs may not exactly match ProcessPlan results.</span>
            </div>
            <div class="fields-section">
                <div class="fields-title">Field Values</div>
                <div id="fieldsContainer" class="fields-grid">
                    <div class="no-fields">No fields detected. Add field tokens like [[FieldName]] to your formula.</div>
                </div>
            </div>
            <div class="output-section">
                <div class="output-title">Compiled Output</div>
                <div id="compilerOutput" class="output-box">Output will appear here after compilation...</div>
            </div>
            <div class="function-status-section">
                <div class="function-status-header">
                    <span class="function-status-title">Function Support</span>
                    <button class="function-status-toggle" onclick="toggleFunctionStatus()">Show Details</button>
                </div>
                <div class="function-status-container" id="functionStatusContainer">
                    <div class="function-status-summary" id="functionStatusSummary"></div>
                    <div class="function-status-grid" id="functionStatusGrid"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="notification" class="notification"></div>

<script>
const FUNCTIONS = new Set([
    '!CONTAINS', '!EQUALS', 'ANYTRUE', 'APPEND', 'BDATE', 'BENUM', 'CALC', 'CEILING',
    'CONTAINS', 'DATEADD', 'DATEDIFF', 'DATELIST', 'DATEPART', 'DATEPATTERN', 'DATEROUND',
    'DATESERIAL', 'DATETIMEMERGE', 'EMAILSPLIT', 'ENCLOSE', 'EQUALS', 'FIRSTVALUE',
    'FISCALMONTH', 'FISCALYEAR', 'FLOOR', 'FORMAT', 'GTDATE', 'GTEDATE', 'GTENUM', 'GTNUM',
    'HASVALUE', 'IF', 'INSTANCECOUNT', 'INSTANCETASKCOUNT', 'INSTANCEUPDATE', 'ISCONTEXT',
    'ISEMPTY', 'ISPUBLICUSER', 'ISTRUE', 'JSONENCODE', 'JSONEXTRACT', 'JSONFIFO', 'JSONINDEX',
    'JSONQUERY', 'JSONREMOVE', 'JSONUPDATE', 'LEFT', 'LEFTOF', 'LEFTOFLAST', 'LENGTH',
    'LINESPLIT', 'LISTASLINES', 'LISTCOUNT', 'LISTDIFF', 'LISTINDEX', 'LISTINTERSECT',
    'LISTITEMAPPEND', 'LISTITEMCONTAINS', 'LISTITEMENDSWITH', 'LISTITEMLEFT', 'LISTITEMLEFTOF',
    'LISTITEMPREPEND', 'LISTITEMREGEX', 'LISTITEMRIGHT', 'LISTITEMRIGHTOF', 'LISTITEMSTARTSWITH',
    'LISTJOIN', 'LISTMERGE', 'LISTUNIQUE', 'LOWERCASE', 'LTDATE', 'LTEDATE', 'LTENUM', 'LTNUM',
    'MAX', 'MIN', 'MONTH', 'MONTHDAY', 'MONTHLASTDAY', 'NORMALIZETEXT', 'NOT', 'NUM', 'NUMSPLIT',
    'PARSE', 'PARTITION', 'RANDOMNUM', 'REGEXFIND', 'REGEXWORDSONLY', 'REMOVECHARS',
    'REMOVEDIACRITICS', 'REMOVESPACES', 'REMOVESYMBOLS', 'REPLACE', 'RIGHT', 'RIGHTOF',
    'RIGHTOFLAST', 'ROUND', 'SPLIT', 'SUM', 'TABLEAVG', 'TABLEJSON', 'TABLELOOKUP', 'TABLESUM',
    'TASKLOOKUP', 'TASKREPORT', 'TITLECASE', 'TRIM', 'UPPERCASE', 'URLENCODE', 'WORDSPLIT',
    'WORKDAY', 'YEAR'
]);

const textarea = document.getElementById('codeTextarea');
const highlight = document.getElementById('codeHighlight');
const lineNumbers = document.getElementById('lineNumbers');
const codeEditor = document.getElementById('codeEditor');
const autocompleteDropdown = document.getElementById('autocompleteDropdown');
const parameterHint = document.getElementById('parameterHint');

let isFormatting = false;

// Helper function to modify textarea while preserving undo/redo history
function insertTextAtCursor(text, selectStart = null, selectEnd = null) {
    textarea.focus();
    // Use execCommand for undo support (works in most browsers)
    document.execCommand('insertText', false, text);
    
    // Set cursor/selection position if specified
    if (selectStart !== null) {
        const pos = selectEnd !== null ? selectEnd : selectStart;
        textarea.setSelectionRange(selectStart, pos);
    }
}

// Helper to replace a range of text while preserving undo history
function replaceTextRange(start, end, newText, cursorPos = null) {
    textarea.focus();
    textarea.setSelectionRange(start, end);
    document.execCommand('insertText', false, newText);
    
    if (cursorPos !== null) {
        textarea.setSelectionRange(cursorPos, cursorPos);
    }
}

// Helper to set entire textarea content while preserving undo history
function setTextareaContent(content, cursorPos = 0) {
    textarea.focus();
    textarea.setSelectionRange(0, textarea.value.length);
    document.execCommand('insertText', false, content);
    textarea.setSelectionRange(cursorPos, cursorPos);
}

// Autocomplete state
let autocompleteVisible = false;
let autocompleteItems = [];
let selectedIndex = 0;
let autocompleteStart = -1;

// Sorted function list for autocomplete
const FUNCTION_LIST = Array.from(FUNCTIONS).sort();

// Function parameters map (from official ProcessPlan documentation)
const FUNCTION_PARAMS = {
    '!CONTAINS': ['DoesThisValueNotExist', 'AnywhereInsideThisValue'],
    '!EQUALS': ['DoesThisValue', 'NotEqualThisValue', 'OrThisValue', '...'],
    'ANYTRUE': ['IsThisFunctionTrue', 'IsThisFunctionTrue', '...'],
    'APPEND': ['Separator', 'Item1', 'Item2', '...'],
    'BDATE': ['IsThisDate', 'GreaterThanThisDate', 'AndLessThanThisDate'],
    'BENUM': ['IsThisNum', 'GreaterThanOrEqualToThisNum', 'AndLessThanOrEqualToThisNum'],
    'CALC': ['MathematicalExpression'],
    'CEILING': ['AnyNumber'],
    'CONTAINS': ['DoesThisValueExist', 'AnywhereInsideThisValue'],
    'DATEADD': ['UnitToIncrement', 'IncrementBy', 'DateToIncrement', 'OptionalMinDate'],
    'DATEDIFF': ['ReturnUnit', 'SubtractThisDate', 'FromThisDate'],
    'DATELIST': ['StartDate', 'EndDate'],
    'DATEPART': ['DatePart', 'DateValue'],
    'DATEPATTERN': ['DateRecurrencePattern', 'EndDateToGenerate', 'RecurrenceAnchorDate', 'StartFromStartDate'],
    'DATEROUND': ['UnitToRoundTo', 'IntervalNum', 'DateToRound'],
    'DATESERIAL': ['Year', 'Month', 'Day'],
    'DATETIMEMERGE': ['DateValue', 'TimeValue'],
    'EMAILSPLIT': ['ReturnIndex', 'EmailAddressText'],
    'ENCLOSE': ['ValueYouWantToHide'],
    'EQUALS': ['DoesThisValue', 'EqualThisValue', 'AndThisValue', '...'],
    'FIRSTVALUE': ['Item1', 'Item2', 'Item3', '...'],
    'FISCALMONTH': ['FiscalYearStartMonthNumber', 'DateToEvaluate'],
    'FISCALYEAR': ['FiscalYearStartMonthNumber', 'DateToEvaluate'],
    'FLOOR': ['AnyNumber'],
    'FORMAT': ['FormatString', 'NumberOrDate'],
    'GTDATE': ['IsThisDate', 'GreaterThanThisDate'],
    'GTEDATE': ['Date1', 'Date2'],
    'GTENUM': ['IsThisNumber', 'GreaterOrEqualToThisNumber'],
    'GTNUM': ['IsThisNumber', 'GreaterThanThisNumber'],
    'HASVALUE': ['DoesAnyValueExistHere'],
    'IF': ['ConditionCheck', 'IfTrueReturnThis', 'AnotherCondition OR IfFalseReturnThis', 'IfTrueReturnThis', 'OptionalIfFalse'],
    'INSTANCECOUNT': ['TableID', 'TableQuery'],
    'INSTANCETASKCOUNT': ['ProcessInstanceID', 'TemplateTaskID'],
    'INSTANCEUPDATE': ['FieldIDToUpdate', 'TableIDToSearch', 'SearchQuery', 'NewFieldValue'],
    'ISCONTEXT': ['ContextIDToTest', 'AnotherOptionalID', '...'],
    'ISEMPTY': ['IsTheValueEmpty'],
    'ISPUBLICUSER': [],
    'ISTRUE': ['IsThisTrue', 'OptionalIsThisTrue', '...'],
    'JSONENCODE': ['TextParameter'],
    'JSONEXTRACT': ['AnyTextContainingJSON'],
    'JSONFIFO': ['ExistingJsonArray', 'NewJsonObjectToAdd', 'MaximumLength'],
    'JSONINDEX': ['IndexToRetrieve', 'ExistingJsonArray'],
    'JSONQUERY': ['JSONPropertyName', 'JSONContainingTheProperty'],
    'JSONREMOVE': ['IndexToRemove', 'ExistingJsonArray'],
    'JSONUPDATE': ['ExistingJsonObject', 'PropertyName', 'PropertyValue'],
    'LEFT': ['Count', 'Value'],
    'LEFTOF': ['ReturnLeftOf', 'SearchInString'],
    'LEFTOFLAST': ['ReturnLeftOf', 'SearchInString'],
    'LENGTH': ['CharacterString'],
    'LINESPLIT': ['IndexOfSplitListToReturn', 'TextToSplit'],
    'LISTASLINES': ['SemicolonSeparatedList'],
    'LISTCOUNT': ['Item1', 'Item2', '...'],
    'LISTDIFF': ['SemicolonSeparatedList1', 'SemicolonSeparatedList2'],
    'LISTINDEX': ['ReturnIndex', 'SemicolonSeparatedTextList'],
    'LISTINTERSECT': ['SemicolonSeparatedList1', 'SemicolonSeparatedList2'],
    'LISTITEMAPPEND': ['AppendText', 'SemicolonSeparatedList'],
    'LISTITEMCONTAINS': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTITEMENDSWITH': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTITEMLEFT': ['NumberOfCharsToReturn', 'SemicolonSeparatedList'],
    'LISTITEMLEFTOF': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTITEMPREPEND': ['PrependText', 'SemicolonSeparatedList'],
    'LISTITEMREGEX': ['RegEx', 'SemicolonSeparatedList'],
    'LISTITEMRIGHT': ['NumberOfCharsToReturn', 'SemicolonSeparatedList'],
    'LISTITEMRIGHTOF': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTITEMSTARTSWITH': ['SearchForText', 'SemicolonSeparatedList'],
    'LISTJOIN': ['NewListItemSeparator', 'SemicolonSeparatedList'],
    'LISTMERGE': ['SemicolonSeparatedList1', 'SemicolonSeparatedList2'],
    'LISTUNIQUE': ['SemicolonSeparatedList'],
    'LOWERCASE': ['String'],
    'LTDATE': ['IsThisDate', 'LessThanThisDate'],
    'LTEDATE': ['IsThisDate', 'LessThanOrEqualToThisDate'],
    'LTENUM': ['Value1', 'Value2'],
    'LTNUM': ['IsThisValue', 'LessThanThisValue'],
    'MAX': ['Parameter1', 'Parameter2', '...'],
    'MIN': ['Parameter1', 'Parameter2', '...'],
    'MONTH': ['DateValue'],
    'MONTHDAY': ['DateValue'],
    'MONTHLASTDAY': ['DateValue', 'OptionalAddOrSubtractDay'],
    'NORMALIZETEXT': ['TextValue'],
    'NOT': ['BooleanParameter'],
    'NUM': ['Parameter'],
    'NUMSPLIT': ['Parameter'],
    'PARSE': ['GetRightOfThisText', 'GetLeftOfThisText', 'SearchWithinThisText'],
    'PARTITION': ['NumberToBePartitioned', 'Divisor'],
    'RANDOMNUM': ['MinimumNumber', 'MaximumNumber'],
    'REGEXFIND': ['RegEx', 'StringToSearch'],
    'REGEXWORDSONLY': ['TextToConvertToRegex'],
    'REMOVECHARS': ['Value', 'CharsToRemove'],
    'REMOVEDIACRITICS': ['Value'],
    'REMOVESPACES': ['Value'],
    'REMOVESYMBOLS': ['Value'],
    'REPLACE': ['SearchForText', 'NewText', 'SearchWithinText'],
    'RIGHT': ['Count', 'Value'],
    'RIGHTOF': ['ReturnRightOf', 'SearchInString'],
    'RIGHTOFLAST': ['ReturnRightOf', 'SearchInString'],
    'ROUND': ['NumOfDecimals', 'AnyNumber'],
    'SPLIT': ['CharacterToSplitOn', 'IndexOfSplitToReturn', 'TextToSplit'],
    'SUM': ['Parameter1', 'Parameter2', '...'],
    'TABLEAVG': ['FieldID', 'TableID', 'TableQuery'],
    'TABLEJSON': ['NumberOfColumns', 'ProcessTableID', 'OptionalTableQuery'],
    'TABLELOOKUP': ['FieldTokenToRetrieve', 'TableID', 'TableQuery'],
    'TABLESUM': ['FieldID', 'TableID', 'TableQuery'],
    'TASKLOOKUP': ['FieldTokenToRetrieve', 'TemplateTaskID', 'TaskQuery'],
    'TASKREPORT': ['TextBlockID', 'ProcessInstanceID', 'IncludeSubprocessTask', 'FilterQuery'],
    'TITLECASE': ['TextParameter'],
    'TRIM': ['TextToTrim'],
    'UPPERCASE': ['String'],
    'URLENCODE': ['CharacterToEncode'],
    'WORDSPLIT': ['ReturnWordIndex', 'PlainText'],
    'WORKDAY': ['WorkScheduleID', 'WorkdaysToSkip', 'DateToStartEvaluatingFrom'],
    'YEAR': ['DateValue']
};

// Get current word being typed (after =)
function getCurrentFunctionPrefix() {
    const cursorPos = textarea.selectionStart;
    const text = textarea.value.substring(0, cursorPos);
    const textAfter = textarea.value.substring(cursorPos);
    
    // Find the last = sign and get text after it
    const lastEquals = text.lastIndexOf('=');
    if (lastEquals === -1) return null;
    
    const afterEquals = text.substring(lastEquals + 1);
    
    // Check if we're still typing the function name (letters, and optionally starting with !)
    if (/^!?[a-zA-Z]*$/.test(afterEquals)) {
        // Check what comes after the cursor
        const afterMatch = textAfter.match(/^(!?[a-zA-Z]*)\s*(\(?)/);
        
        if (afterMatch) {
            const remainingName = afterMatch[1];
            const hasParen = afterMatch[2] === '(';
            const fullName = (afterEquals + remainingName).toUpperCase();
            
            // If there's a parenthesis after, check if the full function name is valid
            if (hasParen) {
                // If the full name is a valid function, block autocomplete (already complete)
                if (FUNCTIONS.has(fullName)) {
                    return null;
                }
                // If invalid function name before existing paren, show autocomplete to fix it
                // Include info about existing parenthesis so we don't duplicate it
                return { 
                    prefix: afterEquals.toUpperCase(), 
                    start: lastEquals,
                    existingParen: true,
                    replaceEnd: cursorPos + remainingName.length
                };
            }
        }
        
        return { prefix: afterEquals.toUpperCase(), start: lastEquals, existingParen: false, replaceEnd: cursorPos };
    }
    
    return null;
}

// Filter and show autocomplete
let autocompleteExistingParen = false;
let autocompleteReplaceEnd = -1;

function updateAutocomplete() {
    const result = getCurrentFunctionPrefix();
    
    if (result === null) {
        hideAutocomplete();
        return;
    }
    
    const { prefix, start, existingParen, replaceEnd } = result;
    autocompleteStart = start;
    autocompleteExistingParen = existingParen;
    autocompleteReplaceEnd = replaceEnd;
    
    // Filter functions that start with the prefix
    autocompleteItems = FUNCTION_LIST.filter(fn => fn.startsWith(prefix));
    
    if (autocompleteItems.length === 0) {
        hideAutocomplete();
        return;
    }
    
    selectedIndex = 0;
    renderAutocomplete();
    positionAutocomplete();
    showAutocomplete();
}

function renderAutocomplete() {
    autocompleteDropdown.innerHTML = autocompleteItems.map((item, index) => 
        `<div class="autocomplete-item${index === selectedIndex ? ' selected' : ''}" data-index="${index}" data-value="${item}">=${item}()</div>`
    ).join('');
    
    // Add click handlers
    autocompleteDropdown.querySelectorAll('.autocomplete-item').forEach(el => {
        el.addEventListener('click', () => {
            selectAutocompleteItem(parseInt(el.dataset.index));
        });
    });
}

function positionAutocomplete() {
    // Get cursor position in textarea
    const cursorPos = textarea.selectionStart;
    
    // Create a temporary span to measure text position
    const textBeforeCursor = textarea.value.substring(0, cursorPos);
    const lines = textBeforeCursor.split('\n');
    const currentLineIndex = lines.length - 1;
    const currentLineText = lines[currentLineIndex];
    
    // Calculate position
    const lineHeight = 20.8; // Approximate line height (13px * 1.6)
    const charWidth = 7.8; // Approximate character width for monospace
    
    const top = (currentLineIndex + 1) * lineHeight + 16; // +16 for padding
    const left = currentLineText.length * charWidth + 16 + 50; // +50 for line numbers width
    
    autocompleteDropdown.style.top = `${Math.min(top, 400)}px`;
    autocompleteDropdown.style.left = `${Math.min(left, 300)}px`;
}

function showAutocomplete() {
    autocompleteDropdown.classList.add('show');
    autocompleteVisible = true;
}

function hideAutocomplete() {
    autocompleteDropdown.classList.remove('show');
    autocompleteVisible = false;
    autocompleteItems = [];
    selectedIndex = 0;
}

function selectAutocompleteItem(index) {
    if (index < 0 || index >= autocompleteItems.length) return;
    
    const selectedFunction = autocompleteItems[index];
    const params = FUNCTION_PARAMS[selectedFunction] || [];
    
    // If there's already a parenthesis, just replace the function name
    if (autocompleteExistingParen) {
        const insertion = `=${selectedFunction}`;
        const newPos = autocompleteStart + insertion.length;
        
        replaceTextRange(autocompleteStart, autocompleteReplaceEnd, insertion, newPos);
        
        hideAutocomplete();
        updateEditor();
        updateParameterHint();
        textarea.focus();
        return;
    }
    
    // Build the full function structure with proper indentation
    const currentText = textarea.value.substring(0, autocompleteStart);
    const lastNewline = currentText.lastIndexOf('\n');
    const currentLineStart = currentText.substring(lastNewline + 1);
    const baseIndent = currentLineStart.match(/^(\t*)/)[1] || '';
    const innerIndent = baseIndent + '\t';
    
    let insertion;
    let cursorOffset;
    
    if (params.length === 0) {
        // No parameters - just insert function with empty parens
        insertion = `=${selectedFunction}()`;
        cursorOffset = insertion.length - 1; // Position cursor inside ()
    } else {
        // Has parameters - create multi-line structure
        insertion = `=${selectedFunction}(\n${innerIndent}\n${baseIndent})`;
        cursorOffset = `=${selectedFunction}(\n${innerIndent}`.length; // Position cursor on the indented line
    }
    
    const newPos = autocompleteStart + cursorOffset;
    
    replaceTextRange(autocompleteStart, autocompleteReplaceEnd, insertion, newPos);
    
    hideAutocomplete();
    updateEditor();
    updateParameterHint();
    textarea.focus();
}

function navigateAutocomplete(direction) {
    if (!autocompleteVisible || autocompleteItems.length === 0) return;
    
    selectedIndex += direction;
    
    if (selectedIndex < 0) selectedIndex = autocompleteItems.length - 1;
    if (selectedIndex >= autocompleteItems.length) selectedIndex = 0;
    
    renderAutocomplete();
    
    // Scroll selected item into view
    const selectedEl = autocompleteDropdown.querySelector('.autocomplete-item.selected');
    if (selectedEl) {
        selectedEl.scrollIntoView({ block: 'nearest' });
    }
}

// Parameter hint functions
function getCurrentFunctionContext() {
    const cursorPos = textarea.selectionStart;
    const text = textarea.value.substring(0, cursorPos);
    
    // Track function calls and their positions
    let functionStack = [];
    let bracketDepth = 0;
    let i = 0;
    
    while (i < text.length) {
        const char = text[i];
        
        // Track brackets to ignore content inside [[ ]]
        if (char === '[') bracketDepth++;
        if (char === ']') bracketDepth = Math.max(0, bracketDepth - 1);
        
        // Look for function pattern: =FUNCTIONNAME( or just FUNCTIONNAME( for nested
        if (bracketDepth === 0) {
            // Check for function start
            let functionMatch = null;
            
            // Check if this could be start of a function name
            if (char === '=' || (functionStack.length > 0 && /[A-Z!]/.test(char))) {
                let nameStart = char === '=' ? i + 1 : i;
                let name = '';
                let j = nameStart;
                
                while (j < text.length && /[A-Z!]/.test(text[j])) {
                    name += text[j];
                    j++;
                }
                
                if (text[j] === '(' && FUNCTIONS.has(name)) {
                    functionStack.push({
                        name: name,
                        paramIndex: 0,
                        start: i
                    });
                    i = j; // Skip to the (
                }
            }
            
            // Count semicolons for current function's parameter index
            if (char === ';' && functionStack.length > 0) {
                functionStack[functionStack.length - 1].paramIndex++;
            }
            
            // Handle closing parenthesis
            if (char === ')' && functionStack.length > 0) {
                functionStack.pop();
            }
        }
        
        i++;
    }
    
    // Return the full function stack (not just innermost)
    return functionStack.length > 0 ? functionStack : null;
}

function updateParameterHint() {
    const contextStack = getCurrentFunctionContext();
    
    if (!contextStack || contextStack.length === 0) {
        hideParameterHint();
        return;
    }
    
    // Build hint HTML for each function in the stack
    const hintLines = contextStack.map((context, stackIndex) => {
        const params = FUNCTION_PARAMS[context.name];
        if (!params || params.length === 0) {
            return null;
        }
        
        const indent = '  '.repeat(stackIndex);
        const paramHtml = params.map((param, index) => {
            const isActive = index === context.paramIndex || 
                            (index === params.length - 1 && context.paramIndex >= params.length);
            // Highlight active param for ALL functions in the stack
            return `<span class="param${isActive ? ' active' : ''}">${param}</span>`;
        }).join('<span class="param">; </span>');
        
        return `<div class="hint-line">${indent}<span class="function-name">${context.name}</span>(${paramHtml})</div>`;
    }).filter(line => line !== null);
    
    if (hintLines.length === 0) {
        hideParameterHint();
        return;
    }
    
    parameterHint.innerHTML = hintLines.join('');
    showParameterHint();
}

function showParameterHint() {
    parameterHint.classList.add('show');
}

function hideParameterHint() {
    parameterHint.classList.remove('show');
}

// Format formula with indentation
function formatFormula(formula) {
    let result = '';
    let indentLevel = 0;
    const indentSize = 3;
    let bracketDepth = 0;
    let inString = false;
    let stringChar = '';

    for (let i = 0; i < formula.length; i++) {
        const char = formula[i];
        
        // Track string literals (single or double quotes)
        if ((char === '"' || char === "'") && (i === 0 || formula[i-1] !== '\\')) {
            if (!inString) {
                inString = true;
                stringChar = char;
            } else if (char === stringChar) {
                inString = false;
            }
        }

        if (char === '[') bracketDepth++;
        if (char === ']') bracketDepth = Math.max(0, bracketDepth - 1);

        // If inside brackets or string, preserve everything as-is
        if (bracketDepth > 0 || inString) {
            result += char;
            continue;
        }

        if (char === '(') {
            result += char;
            indentLevel++;
            if (i + 1 < formula.length && formula[i + 1] !== ')') {
                result += '\n' + ' '.repeat(indentLevel * indentSize);
            }
        } else if (char === ')') {
            indentLevel = Math.max(0, indentLevel - 1);
            if (result.trim().slice(-1) !== '(') {
                result += '\n' + ' '.repeat(indentLevel * indentSize);
            }
            result += char;
        } else if (char === ',' || char === ';') {
            result += char + '\n' + ' '.repeat(indentLevel * indentSize);
        } else if (char.match(/\s/)) {
            // Skip whitespace outside of brackets/strings (formatting handles indentation)
            // But preserve spaces that are part of the content on the current line
            const lastNewline = result.lastIndexOf('\n');
            const currentLine = result.substring(lastNewline + 1);
            // Only skip if we're at the start of a line (after indentation is handled)
            if (currentLine.trim().length > 0) {
                result += char;
            }
        } else {
            result += char;
        }
    }

    // Remove blank lines (lines that contain only whitespace)
    result = result.split('\n').filter(line => line.trim().length > 0).join('\n');

    return result;
}




// Tokenize for syntax highlighting
function tokenize(code) {
    const tokens = [];
    let i = 0;
    let functionDepthStack = [];

    while (i < code.length) {
        // Handle comments - # until end of line
        if (code[i] === '#') {
            let value = '';
            while (i < code.length && code[i] !== '\n') {
                value += code[i];
                i++;
            }
            tokens.push({ type: 'comment', value });
            continue;
        }

        if (/\s/.test(code[i])) {
            let value = '';
            while (i < code.length && /\s/.test(code[i])) {
                value += code[i];
                i++;
            }
            tokens.push({ type: 'whitespace', value });
            continue;
        }

        if (code[i] === '"') {
            let value = '"';
            i++;
            while (i < code.length && code[i] !== '"') {
                value += code[i];
                i++;
            }
            if (i < code.length) {
                value += '"';
                i++;
            }
            tokens.push({ type: 'string', value });
            continue;
        }

        if (code[i] === "'") {
            let value = "'";
            i++;
            while (i < code.length && code[i] !== "'") {
                value += code[i];
                i++;
            }
            if (i < code.length) {
                value += "'";
                i++;
            }
            tokens.push({ type: 'string', value });
            continue;
        }

        if (/\d/.test(code[i])) {
            let value = '';
            while (i < code.length && /[\d.]/.test(code[i])) {
                value += code[i];
                i++;
            }
            tokens.push({ type: 'number', value });
            continue;
        }

        // Handle function names starting with !
        if (code[i] === '!' && i + 1 < code.length && /[a-zA-Z]/.test(code[i + 1])) {
            let value = '!';
            i++;
            while (i < code.length && /[a-zA-Z0-9_]/.test(code[i])) {
                value += code[i];
                i++;
            }
            if (code[i] === '(' && FUNCTIONS.has(value.toUpperCase())) {
                tokens.push({ type: 'function', value: value + '(' });
                functionDepthStack.push(1);
                i++;
            } else {
                tokens.push({ type: 'identifier', value });
            }
            continue;
        }

        if (/[a-zA-Z_]/.test(code[i])) {
            let value = '';
            while (i < code.length && /[a-zA-Z0-9_]/.test(code[i])) {
                value += code[i];
                i++;
            }
            if (code[i] === '(' && FUNCTIONS.has(value.toUpperCase())) {
                tokens.push({ type: 'function', value: value + '(' });
                functionDepthStack.push(1);
                i++;
            } else {
                tokens.push({ type: 'identifier', value });
            }
            continue;
        }

        if (code[i] === '(') {
            for (let j = 0; j < functionDepthStack.length; j++) {
                functionDepthStack[j]++;
            }
            tokens.push({ type: 'parenthesis', value: '(' });
            i++;
            continue;
        }

        if (code[i] === ')') {
            let isClosingFunction = false;
            for (let j = functionDepthStack.length - 1; j >= 0; j--) {
                functionDepthStack[j]--;
                if (functionDepthStack[j] === 0) {
                    isClosingFunction = true;
                    functionDepthStack.splice(j, 1);
                    break;
                }
            }
            tokens.push({ type: isClosingFunction ? 'function' : 'parenthesis', value: ')' });
            i++;
            continue;
        }

        if (/[+\-*\/=<>&|;,]/.test(code[i])) {
            tokens.push({ type: 'operator', value: code[i] });
            i++;
            continue;
        }

        if (code[i] === '[' || code[i] === ']') {
            tokens.push({ type: 'bracket', value: code[i] });
            i++;
            continue;
        }

        tokens.push({ type: 'other', value: code[i] });
        i++;
    }

    return tokens;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function applySyntaxHighlighting(code) {
    const tokens = tokenize(code);
    return tokens.map(token => {
        const escaped = escapeHtml(token.value);
        switch (token.type) {
            case 'function': return `<span class="function">${escaped}</span>`;
            case 'string': return `<span class="string">${escaped}</span>`;
            case 'number': return `<span class="number">${escaped}</span>`;
            case 'operator': return `<span class="operator">${escaped}</span>`;
            case 'parenthesis': return `<span class="parenthesis">${escaped}</span>`;
            case 'bracket': return `<span class="bracket">${escaped}</span>`;
            case 'comment': return `<span class="comment">${escaped}</span>`;
            default: return escaped;
        }
    }).join('');
}

function updateLineNumbers(code) {
    const lines = code.split('\n');
    lineNumbers.innerHTML = lines.map((_, i) => 
        `<div class="line-number">${i + 1}</div>`
    ).join('');
}

function updateEditor() {
    const code = textarea.value;
    highlight.innerHTML = applySyntaxHighlighting(code) + '\n';
    updateLineNumbers(code);
}

function formatLive() {
    const raw = textarea.value;
    const formatted = addIndentationAndSpacing(raw);
    const highlighted = applySyntaxHighlighting(formatted);
    formattedCode.innerHTML = highlighted;
}

// Handle paste - format the pasted content
textarea.addEventListener('paste', (e) => {
    e.preventDefault();
    const pastedText = e.clipboardData.getData('text');
    const formatted = formatFormula(pastedText);
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const newPos = start + formatted.length;
    
    replaceTextRange(start, end, formatted, newPos);
    
    updateEditor();
    hideAutocomplete();
    updateParameterHint();
    extractAndDisplayFields();
    showNotification('Formula formatted!');
});

// Hide autocomplete when clicking outside
document.addEventListener('click', (e) => {
    if (!autocompleteDropdown.contains(e.target) && e.target !== textarea) {
        hideAutocomplete();
        hideParameterHint();
    }
});

// Update parameter hint and autocomplete on cursor movement (click)
textarea.addEventListener('click', () => {
    updateAutocomplete();
    updateParameterHint();
});

textarea.addEventListener('keyup', (e) => {
    // Update on arrow keys for cursor movement (but not when navigating autocomplete)
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key)) {
        if (!autocompleteVisible) {
            updateAutocomplete();
        }
        updateParameterHint();
    }
});

// Hide hints when textarea loses focus
textarea.addEventListener('blur', () => {
    // Small delay to allow clicking on autocomplete items
    setTimeout(() => {
        if (document.activeElement !== textarea && !autocompleteDropdown.contains(document.activeElement)) {
            hideAutocomplete();
            hideParameterHint();
        }
    }, 150);
});

// Restore hints when textarea gains focus
textarea.addEventListener('focus', () => {
    updateAutocomplete();
    updateParameterHint();
});

// Handle input for live updates (includes undo/redo)
textarea.addEventListener('input', (e) => {
    updateEditor();
    updateAutocomplete();
    updateParameterHint();
    extractAndDisplayFields();
    formatLive();
});

// Sync scroll between textarea, highlight, and line numbers
textarea.addEventListener('scroll', () => {
    // Use transform for smoother sync of highlight layer
    highlight.style.transform = `translate(${-textarea.scrollLeft}px, ${-textarea.scrollTop}px)`;
    // Sync line numbers vertically
    lineNumbers.style.transform = `translateY(${-textarea.scrollTop}px)`;
});

// Handle tab key
textarea.addEventListener('keydown', (e) => {
    // Handle autocomplete navigation
    if (autocompleteVisible) {
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            navigateAutocomplete(1);
            return;
        }
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            navigateAutocomplete(-1);
            return;
        }
        if (e.key === 'Enter' || e.key === 'Tab') {
            e.preventDefault();
            selectAutocompleteItem(selectedIndex);
            return;
        }
        if (e.key === 'Escape') {
            e.preventDefault();
            hideAutocomplete();
            return;
        }
    }
    
    // Handle Enter - maintain current indentation
    if (e.key === 'Enter' && !autocompleteVisible) {
        e.preventDefault();
        
        const cursorPos = textarea.selectionStart;
        const textBefore = textarea.value.substring(0, cursorPos);
        
        // Get the current line's indentation
        const lastNewline = textBefore.lastIndexOf('\n');
        const currentLine = textBefore.substring(lastNewline + 1);
        const indentMatch = currentLine.match(/^(\s*)/);
        const currentIndent = indentMatch ? indentMatch[1] : '';
        
        // Check if we're after an opening parenthesis - add extra indent
        const charBefore = textBefore.trimEnd().slice(-1);
        const indentSize = 3;
        let insertion;
        
        if (charBefore === '(') {
            // Add extra indentation after opening paren
            const extraIndent = currentIndent + ' '.repeat(indentSize);
            insertion = '\n' + extraIndent;
        } else {
            insertion = '\n' + currentIndent;
        }
        
        const newPos = cursorPos + insertion.length;
        
        insertTextAtCursor(insertion, newPos, newPos);
        updateEditor();
        return;
    }
    
    // Handle Backspace - delete entire indent level if cursor is in leading whitespace
    if (e.key === 'Backspace') {
        const cursorPos = textarea.selectionStart;
        const selectionEnd = textarea.selectionEnd;
        
        // Only handle if no text is selected
        if (cursorPos === selectionEnd && cursorPos > 0) {
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            
            // Get current line info
            const lastNewline = textBefore.lastIndexOf('\n');
            const currentLineStart = lastNewline + 1;
            const textOnCurrentLine = textBefore.substring(currentLineStart);
            
            // Check if we're in leading whitespace (only spaces before cursor on this line)
            if (/^\s+$/.test(textOnCurrentLine)) {
                const indentSize = 3;
                const currentIndentLength = textOnCurrentLine.length;
                
                // Calculate how many spaces to remove to get to previous indent level
                const spacesToRemove = currentIndentLength % indentSize === 0 
                    ? indentSize 
                    : currentIndentLength % indentSize;
                
                if (spacesToRemove > 0 && currentIndentLength >= spacesToRemove) {
                    e.preventDefault();
                    
                    const newPos = cursorPos - spacesToRemove;
                    replaceTextRange(newPos, cursorPos, '', newPos);
                    
                    updateEditor();
                    return;
                }
            }
        }
    }
    
    // Handle Tab - indent selection or insert spaces
    if (e.key === 'Tab') {
        e.preventDefault();
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const indentSize = 3;
        const indent = ' '.repeat(indentSize);
        
        // Check if there's a selection spanning multiple characters
        if (start !== end) {
            const text = textarea.value;
            
            // Find the start of the first selected line
            let lineStart = start;
            while (lineStart > 0 && text[lineStart - 1] !== '\n') {
                lineStart--;
            }
            
            // Find the end of the last selected line
            let lineEnd = end;
            while (lineEnd < text.length && text[lineEnd] !== '\n') {
                lineEnd++;
            }
            
            // Get the selected lines
            const selectedText = text.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            let newText;
            let newStart, newEnd;
            
            if (e.shiftKey) {
                // Shift+Tab: Unindent
                newText = lines.map(line => {
                    if (line.startsWith(indent)) {
                        return line.substring(indentSize);
                    } else if (line.startsWith(' ')) {
                        // Remove as many leading spaces as possible up to indentSize
                        let spacesToRemove = 0;
                        while (spacesToRemove < indentSize && line[spacesToRemove] === ' ') {
                            spacesToRemove++;
                        }
                        return line.substring(spacesToRemove);
                    }
                    return line;
                }).join('\n');
                
                const diff = selectedText.length - newText.length;
                newStart = Math.max(lineStart, start - (lines[0].length - (newText.split('\n')[0] || '').length));
                newEnd = end - diff;
            } else {
                // Tab: Indent
                newText = lines.map(line => indent + line).join('\n');
                newStart = start + indentSize;
                newEnd = end + (lines.length * indentSize);
            }
            
            // Replace the text
            textarea.setSelectionRange(lineStart, lineEnd);
            document.execCommand('insertText', false, newText);
            
            // Restore selection
            textarea.setSelectionRange(
                Math.max(0, newStart),
                Math.min(textarea.value.length, newEnd)
            );
            
            updateEditor();
        } else {
            // No selection - just insert spaces
            insertTextAtCursor(indent, start + indentSize, start + indentSize);
            updateEditor();
        }
    }
});

// Calculate indent level based on unmatched opening parens (outside brackets)
function getIndentLevel(text) {
    let level = 0;
    let bracketDepth = 0;
    
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (char === '[') bracketDepth++;
        if (char === ']') bracketDepth = Math.max(0, bracketDepth - 1);
        
        if (bracketDepth === 0) {
            if (char === '(') level++;
            if (char === ')') level = Math.max(0, level - 1);
        }
    }
    
    return level;
}

// Copy formatted (with indentation)
// Remove comments from code
function stripComments(code) {
    // Remove comments (# to end of line) but preserve the newline
    return code.replace(/#[^\n]*/g, '');
}

function copyFormatted() {
    const code = textarea.value;
    if (!code.trim()) {
        showNotification('Nothing to copy!', 'error');
        return;
    }
    // Strip comments but keep formatting
    let cleaned = stripComments(code);
    // Remove empty lines that were just comments
    cleaned = cleaned.split('\n').filter(line => line.trim() !== '').join('\n');
    
    navigator.clipboard.writeText(cleaned)
        .then(() => showNotification('Copied formatted!'))
        .catch(() => showNotification('Failed to copy', 'error'));
}

// Copy raw (without formatting)
function copyRaw() {
    const code = textarea.value;
    if (!code.trim()) {
        showNotification('Nothing to copy!', 'error');
        return;
    }
    // Strip comments first
    let raw = stripComments(code);
    raw = raw.replace(/[\n\r\t]+/g, '');
    raw = raw.replace(/\(\s+/g, '(').replace(/\s+\)/g, ')');
    // Clean up any extra spaces left from removed comments
    raw = raw.replace(/\s+/g, ' ').replace(/; /g, ';').replace(/ ;/g, ';');
    
    navigator.clipboard.writeText(raw)
        .then(() => showNotification('Copied raw!'))
        .catch(() => showNotification('Failed to copy', 'error'));
}

function clearEditor() {
    setTextareaContent('', 0);
    updateEditor();
    extractAndDisplayFields();
    showNotification('Cleared!');
}

function showNotification(message, type = 'success') {
    const notification = document.getElementById('notification');
    notification.textContent = message;
    notification.className = 'notification' + (type === 'error' ? ' error' : '');
    notification.classList.add('show');
    setTimeout(() => notification.classList.remove('show'), 2500);
}

// Help modal
function toggleHelpModal() {
    document.getElementById('helpModal').classList.toggle('show');
    document.getElementById('helpModalOverlay').classList.toggle('show');
}

// Theme toggle
function toggleTheme() {
    const body = document.body;
    const themeIcon = document.querySelector('.theme-icon');
    
    body.classList.toggle('light-mode');
    
    const isLight = body.classList.contains('light-mode');
    themeIcon.textContent = isLight ? '‚òÄÔ∏è' : 'üåô';
    
    // Save preference to localStorage
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
}

// Load saved theme on page load
function loadSavedTheme() {
    const savedTheme = localStorage.getItem('theme');
    const themeIcon = document.querySelector('.theme-icon');
    
    if (savedTheme === 'light') {
        document.body.classList.add('light-mode');
        themeIcon.textContent = '‚òÄÔ∏è';
    }
}

// Sidebar functions
function toggleSidebar() {
    document.getElementById('sidebar').classList.toggle('open');
    document.getElementById('sidebarOverlay').classList.toggle('show');
}

// Left Sidebar - Saved Formulas functions
function toggleFormulasSidebar() {
    document.getElementById('leftSidebar').classList.toggle('open');
    document.getElementById('leftSidebarOverlay').classList.toggle('show');
}

// Get saved formulas from localStorage
function getSavedFormulas() {
    const formulas = localStorage.getItem('savedFormulas');
    return formulas ? JSON.parse(formulas) : [];
}

// Save formulas to localStorage
function setSavedFormulas(formulas) {
    localStorage.setItem('savedFormulas', JSON.stringify(formulas));
}

// Save current formula
function saveFormula() {
    const nameInput = document.getElementById('formulaNameInput');
    const name = nameInput.value.trim();
    const content = textarea.value;
    
    if (!name) {
        showNotification('Please enter a formula name', 'error');
        nameInput.focus();
        return;
    }
    
    if (!content.trim()) {
        showNotification('Cannot save empty formula', 'error');
        return;
    }
    
    const formulas = getSavedFormulas();
    
    // Check if name already exists
    const existingIndex = formulas.findIndex(f => f.name.toLowerCase() === name.toLowerCase());
    
    const formula = {
        id: existingIndex >= 0 ? formulas[existingIndex].id : Date.now().toString(),
        name: name,
        content: content,
        updatedAt: new Date().toISOString()
    };
    
    if (existingIndex >= 0) {
        formulas[existingIndex] = formula;
        showNotification(`Formula "${name}" updated!`);
    } else {
        formulas.unshift(formula);
        showNotification(`Formula "${name}" saved!`);
    }
    
    setSavedFormulas(formulas);
    nameInput.value = '';
    renderFormulasList();
}

// Load a formula into the editor
function loadFormula(id) {
    const formulas = getSavedFormulas();
    const formula = formulas.find(f => f.id === id);
    
    if (formula) {
        setTextareaContent(formula.content, formula.content.length);
        document.getElementById('formulaNameInput').value = formula.name;
        updateEditor();
        extractAndDisplayFields();
        toggleFormulasSidebar();
        showNotification(`Loaded "${formula.name}"`);
    }
}

// Delete a formula
function deleteFormula(id, event) {
    event.stopPropagation();
    
    const formulas = getSavedFormulas();
    const formula = formulas.find(f => f.id === id);
    
    if (formula && confirm(`Delete "${formula.name}"?`)) {
        const updatedFormulas = formulas.filter(f => f.id !== id);
        setSavedFormulas(updatedFormulas);
        renderFormulasList();
        showNotification(`Deleted "${formula.name}"`);
    }
}

// Format date for display
function formatDate(isoString) {
    const date = new Date(isoString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins} min ago`;
    if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    
    return date.toLocaleDateString();
}

// Render the formulas list
function renderFormulasList() {
    const formulas = getSavedFormulas();
    const container = document.getElementById('formulasList');
    
    if (formulas.length === 0) {
        container.innerHTML = `
            <div class="no-formulas">
                <div class="no-formulas-icon">üìÅ</div>
                <div>No saved formulas yet</div>
            </div>
        `;
        return;
    }
    
    container.innerHTML = formulas.map(formula => `
        <div class="formula-item" onclick="loadFormula('${formula.id}')">
            <div class="formula-item-info">
                <div class="formula-item-name">${escapeHtml(formula.name)}</div>
                <div class="formula-item-date">${formatDate(formula.updatedAt)}</div>
            </div>
            <div class="formula-item-actions">
                <button class="formula-action-btn delete" onclick="deleteFormula('${formula.id}', event)" title="Delete">üóëÔ∏è</button>
            </div>
        </div>
    `).join('');
}

// Export all formulas to a JSON file
function exportFormulas() {
    const formulas = getSavedFormulas();
    
    if (formulas.length === 0) {
        showNotification('No formulas to export', 'error');
        return;
    }
    
    const exportData = {
        version: 1,
        exportedAt: new Date().toISOString(),
        formulas: formulas
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `formulas-export-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showNotification(`Exported ${formulas.length} formula${formulas.length > 1 ? 's' : ''}`);
}

// Import formulas from a JSON file
function importFormulas(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            
            // Validate the import data
            if (!data.formulas || !Array.isArray(data.formulas)) {
                showNotification('Invalid import file format', 'error');
                return;
            }
            
            const existingFormulas = getSavedFormulas();
            const existingNames = new Set(existingFormulas.map(f => f.name.toLowerCase()));
            
            let imported = 0;
            let skipped = 0;
            
            for (const formula of data.formulas) {
                // Validate each formula has required fields
                if (!formula.name || !formula.content) {
                    skipped++;
                    continue;
                }
                
                // Check for duplicates by name
                if (existingNames.has(formula.name.toLowerCase())) {
                    // Update existing formula
                    const existingIndex = existingFormulas.findIndex(
                        f => f.name.toLowerCase() === formula.name.toLowerCase()
                    );
                    if (existingIndex >= 0) {
                        existingFormulas[existingIndex] = {
                            ...existingFormulas[existingIndex],
                            content: formula.content,
                            updatedAt: new Date().toISOString()
                        };
                        imported++;
                    }
                } else {
                    // Add new formula
                    existingFormulas.unshift({
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                        name: formula.name,
                        content: formula.content,
                        updatedAt: formula.updatedAt || new Date().toISOString()
                    });
                    existingNames.add(formula.name.toLowerCase());
                    imported++;
                }
            }
            
            setSavedFormulas(existingFormulas);
            renderFormulasList();
            
            if (imported > 0) {
                showNotification(`Imported ${imported} formula${imported > 1 ? 's' : ''}${skipped > 0 ? `, ${skipped} skipped` : ''}`);
            } else {
                showNotification('No formulas were imported', 'error');
            }
        } catch (err) {
            showNotification('Failed to parse import file', 'error');
            console.error('Import error:', err);
        }
    };
    
    reader.readAsText(file);
    
    // Reset the file input so the same file can be imported again
    event.target.value = '';
}

// Compiler functions
let fieldValues = {};

function extractFields(code) {
    const fieldPattern = /\[\[\s*([^\]]+?)\s*\]\]/g;
    const fields = new Set();
    let match;
    
    while ((match = fieldPattern.exec(code)) !== null) {
        fields.add(match[1].trim());
    }
    
    return Array.from(fields).sort();
}

function extractAndDisplayFields() {
    const code = textarea.value;
    const fields = extractFields(code);
    const container = document.getElementById('fieldsContainer');
    
    if (fields.length === 0) {
        container.innerHTML = '<div class="no-fields">No fields detected. Add field tokens like [[FieldName]] to your formula.</div>';
        return;
    }
    
    // Preserve existing values
    const oldValues = { ...fieldValues };
    fieldValues = {};
    
    container.innerHTML = fields.map(field => {
        const existingValue = oldValues[field] || '';
        fieldValues[field] = existingValue;
        return `
            <div class="field-item">
                <label class="field-label">[[ ${field} ]]</label>
                <input type="text" 
                       class="field-input" 
                       placeholder="Enter value..."
                       value="${escapeHtml(existingValue)}"
                       onchange="updateFieldValue('${escapeHtml(field)}', this.value)"
                       oninput="updateFieldValue('${escapeHtml(field)}', this.value)">
            </div>
        `;
    }).join('');
}

function updateFieldValue(field, value) {
    fieldValues[field] = value;
}

// ============================================
// FORMULA COMPILER - Tokenizer, Parser, Evaluator
// ============================================

// Function implementation status
const FUNCTION_STATUS = {
    // Fully implemented
    'APPEND': 'implemented',
    'CALC': 'implemented',
    'CEILING': 'implemented',
    'CONTAINS': 'implemented',
    '!CONTAINS': 'implemented',
    'EQUALS': 'implemented',
    '!EQUALS': 'implemented',
    'FLOOR': 'implemented',
    'HASVALUE': 'implemented',
    'IF': 'implemented',
    'ISEMPTY': 'implemented',
    'ISTRUE': 'implemented',
    'ANYTRUE': 'implemented',
    'NOT': 'implemented',
    'LEFT': 'implemented',
    'RIGHT': 'implemented',
    'LEFTOF': 'implemented',
    'RIGHTOF': 'implemented',
    'LEFTOFLAST': 'implemented',
    'RIGHTOFLAST': 'implemented',
    'LENGTH': 'implemented',
    'LOWERCASE': 'implemented',
    'UPPERCASE': 'implemented',
    'TITLECASE': 'implemented',
    'TRIM': 'implemented',
    'REPLACE': 'implemented',
    'REMOVECHARS': 'implemented',
    'REMOVESPACES': 'implemented',
    'NUM': 'implemented',
    'ROUND': 'implemented',
    'MAX': 'implemented',
    'MIN': 'implemented',
    'SUM': 'implemented',
    'GTNUM': 'implemented',
    'GTENUM': 'implemented',
    'LTNUM': 'implemented',
    'LTENUM': 'implemented',
    'BENUM': 'implemented',
    'FIRSTVALUE': 'implemented',
    'SPLIT': 'implemented',
    'LISTCOUNT': 'implemented',
    'LISTINDEX': 'implemented',
    'LISTJOIN': 'implemented',
    'LISTMERGE': 'implemented',
    'LISTDIFF': 'implemented',
    'LISTINTERSECT': 'implemented',
    'LISTUNIQUE': 'implemented',
    'LISTASLINES': 'implemented',
    'LINESPLIT': 'implemented',
    'PARSE': 'implemented',
    'ENCLOSE': 'implemented',
    'RANDOMNUM': 'implemented',
    'PARTITION': 'implemented',
    'REGEXFIND': 'implemented',
    'FORMAT': 'implemented',
    
    // Date functions - implemented
    'YEAR': 'implemented',
    'MONTH': 'implemented',
    'MONTHDAY': 'implemented',
    'DATEPART': 'implemented',
    'DATESERIAL': 'implemented',
    'DATEDIFF': 'implemented',
    'DATEADD': 'implemented',
    'GTDATE': 'implemented',
    'GTEDATE': 'implemented',
    'LTDATE': 'implemented',
    'LTEDATE': 'implemented',
    'BDATE': 'implemented',
    'MONTHLASTDAY': 'implemented',
    
    // JSON functions - implemented
    'JSONENCODE': 'implemented',
    'JSONQUERY': 'implemented',
    'JSONEXTRACT': 'implemented',
    'JSONUPDATE': 'implemented',
    'JSONINDEX': 'implemented',
    'JSONREMOVE': 'implemented',
    'JSONFIFO': 'implemented',
    
    // Partial implementations (work but may have limitations)
    'DATELIST': 'partial',
    'DATETIMEMERGE': 'partial',
    'FISCALMONTH': 'partial',
    'FISCALYEAR': 'partial',
    'DATEROUND': 'partial',
    'EMAILSPLIT': 'partial',
    'WORDSPLIT': 'partial',
    'NUMSPLIT': 'partial',
    'LISTITEMAPPEND': 'partial',
    'LISTITEMPREPEND': 'partial',
    'LISTITEMCONTAINS': 'partial',
    'LISTITEMSTARTSWITH': 'partial',
    'LISTITEMENDSWITH': 'partial',
    'LISTITEMLEFT': 'partial',
    'LISTITEMRIGHT': 'partial',
    'LISTITEMLEFTOF': 'partial',
    'LISTITEMRIGHTOF': 'partial',
    'LISTITEMREGEX': 'partial',
    'REMOVEDIACRITICS': 'partial',
    'REMOVESYMBOLS': 'partial',
    'NORMALIZETEXT': 'partial',
    'REGEXWORDSONLY': 'partial',
    'URLENCODE': 'partial',
    
    // Cannot implement - require ProcessPlan backend
    'TABLELOOKUP': 'not-implemented',
    'TABLESUM': 'not-implemented',
    'TABLEAVG': 'not-implemented',
    'TABLEJSON': 'not-implemented',
    'TASKLOOKUP': 'not-implemented',
    'TASKREPORT': 'not-implemented',
    'INSTANCECOUNT': 'not-implemented',
    'INSTANCETASKCOUNT': 'not-implemented',
    'INSTANCEUPDATE': 'not-implemented',
    'ISCONTEXT': 'not-implemented',
    'ISPUBLICUSER': 'not-implemented',
    'WORKDAY': 'not-implemented',
    'DATEPATTERN': 'not-implemented',
};

// Compiler Tokenizer
function compilerTokenize(formula) {
    const tokens = [];
    let i = 0;
    
    while (i < formula.length) {
        // Skip whitespace
        if (/\s/.test(formula[i])) {
            i++;
            continue;
        }
        
        // Skip comments
        if (formula[i] === '#') {
            while (i < formula.length && formula[i] !== '\n') i++;
            continue;
        }
        
        // Field reference [[...]]
        if (formula[i] === '[' && formula[i + 1] === '[') {
            let value = '';
            i += 2;
            while (i < formula.length && !(formula[i] === ']' && formula[i + 1] === ']')) {
                value += formula[i];
                i++;
            }
            i += 2; // Skip ]]
            tokens.push({ type: 'FIELD', value: value.trim() });
            continue;
        }
        
        // String literal (double quotes)
        if (formula[i] === '"') {
            let value = '';
            i++;
            while (i < formula.length && formula[i] !== '"') {
                if (formula[i] === '\\' && i + 1 < formula.length) {
                    value += formula[i + 1];
                    i += 2;
                } else {
                    value += formula[i];
                    i++;
                }
            }
            i++; // Skip closing quote
            tokens.push({ type: 'STRING', value });
            continue;
        }
        
        // String literal (single quotes)
        if (formula[i] === "'") {
            let value = '';
            i++;
            while (i < formula.length && formula[i] !== "'") {
                value += formula[i];
                i++;
            }
            i++; // Skip closing quote
            tokens.push({ type: 'STRING', value });
            continue;
        }
        
        // Number
        if (/\d/.test(formula[i]) || (formula[i] === '-' && /\d/.test(formula[i + 1]))) {
            let value = '';
            if (formula[i] === '-') {
                value += '-';
                i++;
            }
            while (i < formula.length && /[\d.]/.test(formula[i])) {
                value += formula[i];
                i++;
            }
            tokens.push({ type: 'NUMBER', value: parseFloat(value) });
            continue;
        }
        
        // Function call starting with = and possibly !
        if (formula[i] === '=') {
            i++;
            let name = '';
            if (formula[i] === '!') {
                name += '!';
                i++;
            }
            while (i < formula.length && /[a-zA-Z0-9_]/.test(formula[i])) {
                name += formula[i];
                i++;
            }
            tokens.push({ type: 'FUNCTION', value: name.toUpperCase() });
            continue;
        }
        
        // Operators and delimiters
        if (formula[i] === '(') {
            tokens.push({ type: 'LPAREN', value: '(' });
            i++;
            continue;
        }
        if (formula[i] === ')') {
            tokens.push({ type: 'RPAREN', value: ')' });
            i++;
            continue;
        }
        if (formula[i] === ';') {
            tokens.push({ type: 'SEMICOLON', value: ';' });
            i++;
            continue;
        }
        if (formula[i] === ',') {
            tokens.push({ type: 'COMMA', value: ',' });
            i++;
            continue;
        }
        
        // Arithmetic operators for CALC
        if (/[+\-*/%]/.test(formula[i])) {
            tokens.push({ type: 'OPERATOR', value: formula[i] });
            i++;
            continue;
        }
        
        // Plain text/identifier (until we hit a delimiter)
        let text = '';
        while (i < formula.length && !/[\s\[\]();,=]/.test(formula[i])) {
            text += formula[i];
            i++;
        }
        if (text) {
            // Check if it looks like a date
            if (/^\d{4}-\d{2}-\d{2}/.test(text)) {
                tokens.push({ type: 'DATE', value: text });
            } else if (/^\d+$/.test(text)) {
                tokens.push({ type: 'NUMBER', value: parseInt(text) });
            } else if (/^\d*\.\d+$/.test(text)) {
                tokens.push({ type: 'NUMBER', value: parseFloat(text) });
            } else {
                tokens.push({ type: 'TEXT', value: text });
            }
        }
    }
    
    return tokens;
}

// AST Node types
class ASTNode {
    constructor(type, value = null, children = []) {
        this.type = type;
        this.value = value;
        this.children = children;
    }
}

// Parser
class FormulaParser {
    constructor(tokens) {
        this.tokens = tokens;
        this.pos = 0;
    }
    
    current() {
        return this.tokens[this.pos];
    }
    
    consume(expectedType = null) {
        const token = this.current();
        if (expectedType && (!token || token.type !== expectedType)) {
            throw new Error(`Expected ${expectedType} but got ${token ? token.type : 'EOF'}`);
        }
        this.pos++;
        return token;
    }
    
    peek(offset = 0) {
        return this.tokens[this.pos + offset];
    }
    
    parse() {
        const nodes = [];
        while (this.pos < this.tokens.length) {
            nodes.push(this.parseExpression());
        }
        // If multiple top-level nodes, concatenate them
        if (nodes.length === 1) return nodes[0];
        return new ASTNode('CONCAT', null, nodes);
    }
    
    parseExpression() {
        const token = this.current();
        if (!token) return new ASTNode('LITERAL', '');
        
        if (token.type === 'FUNCTION') {
            return this.parseFunctionCall();
        }
        if (token.type === 'FIELD') {
            this.consume();
            return new ASTNode('FIELD', token.value);
        }
        if (token.type === 'STRING') {
            this.consume();
            return new ASTNode('LITERAL', token.value);
        }
        if (token.type === 'NUMBER') {
            this.consume();
            return new ASTNode('LITERAL', token.value);
        }
        if (token.type === 'DATE') {
            this.consume();
            return new ASTNode('LITERAL', token.value);
        }
        if (token.type === 'TEXT') {
            this.consume();
            return new ASTNode('LITERAL', token.value);
        }
        if (token.type === 'OPERATOR') {
            this.consume();
            return new ASTNode('LITERAL', token.value);
        }
        
        // Skip unexpected tokens
        this.consume();
        return new ASTNode('LITERAL', '');
    }
    
    parseFunctionCall() {
        const funcToken = this.consume('FUNCTION');
        const funcName = funcToken.value;
        
        this.consume('LPAREN');
        
        const args = [];
        while (this.current() && this.current().type !== 'RPAREN') {
            // Collect all tokens until semicolon or rparen as one argument
            const argParts = [];
            let parenDepth = 0;
            
            while (this.current()) {
                const cur = this.current();
                
                if (cur.type === 'LPAREN') parenDepth++;
                if (cur.type === 'RPAREN') {
                    if (parenDepth === 0) break;
                    parenDepth--;
                }
                if ((cur.type === 'SEMICOLON' || cur.type === 'COMMA') && parenDepth === 0) break;
                
                if (cur.type === 'FUNCTION') {
                    argParts.push(this.parseFunctionCall());
                } else {
                    argParts.push(this.parseExpression());
                }
            }
            
            // Combine argument parts
            if (argParts.length === 1) {
                args.push(argParts[0]);
            } else if (argParts.length > 1) {
                args.push(new ASTNode('CONCAT', null, argParts));
            }
            
            // Skip semicolon/comma separator
            if (this.current() && (this.current().type === 'SEMICOLON' || this.current().type === 'COMMA')) {
                this.consume();
            }
        }
        
        this.consume('RPAREN');
        
        return new ASTNode('FUNCTION', funcName, args);
    }
}

// Evaluator
class FormulaEvaluator {
    constructor(fieldValues) {
        this.fieldValues = fieldValues;
    }
    
    evaluate(node) {
        if (!node) return '';
        
        switch (node.type) {
            case 'LITERAL':
                return node.value;
                
            case 'FIELD':
                return this.fieldValues[node.value] ?? `[[${node.value}]]`;
                
            case 'CONCAT':
                return node.children.map(c => this.stringify(this.evaluate(c))).join('');
                
            case 'FUNCTION':
                return this.evaluateFunction(node.value, node.children);
                
            default:
                return '';
        }
    }
    
    stringify(value) {
        if (value === null || value === undefined) return '';
        if (typeof value === 'boolean') return value ? '1' : '0';
        return String(value);
    }
    
    toNumber(value) {
        if (typeof value === 'number') return value;
        const str = this.stringify(value).replace(/[^0-9.\-]/g, '');
        return parseFloat(str) || 0;
    }
    
    toBoolean(value) {
        if (typeof value === 'boolean') return value;
        if (typeof value === 'number') return value > 0;
        const str = this.stringify(value).toLowerCase();
        return str === 'true' || str === '1' || (parseFloat(str) > 0);
    }
    
    parseDate(value) {
        const str = this.stringify(value);
        const d = new Date(str);
        return isNaN(d.getTime()) ? null : d;
    }
    
    evaluateFunction(name, argNodes) {
        const status = FUNCTION_STATUS[name];
        if (status === 'not-implemented') {
            return `[${name}: Not available - requires ProcessPlan backend]`;
        }
        
        // Helper to evaluate args lazily
        const evalArg = (index) => this.evaluate(argNodes[index]);
        const evalAllArgs = () => argNodes.map(n => this.evaluate(n));
        
        switch (name) {
            // String functions
            case 'APPEND': {
                const args = evalAllArgs();
                const separator = this.stringify(args[0]);
                return args.slice(1).map(a => this.stringify(a)).filter(s => s !== '').join(separator);
            }
            
            case 'CONTAINS': {
                const search = this.stringify(evalArg(0)).toLowerCase();
                const text = this.stringify(evalArg(1)).toLowerCase();
                return text.includes(search) ? 1 : 0;
            }
            
            case '!CONTAINS': {
                const search = this.stringify(evalArg(0)).toLowerCase();
                const text = this.stringify(evalArg(1)).toLowerCase();
                return !text.includes(search) ? 1 : 0;
            }
            
            case 'EQUALS': {
                const args = evalAllArgs();
                const first = this.stringify(args[0]);
                return args.slice(1).every(a => this.stringify(a) === first) ? 1 : 0;
            }
            
            case '!EQUALS': {
                const args = evalAllArgs();
                const first = this.stringify(args[0]);
                return args.slice(1).every(a => this.stringify(a) !== first) ? 1 : 0;
            }
            
            case 'LEFT': {
                const count = this.toNumber(evalArg(0));
                const str = this.stringify(evalArg(1));
                return str.substring(0, count);
            }
            
            case 'RIGHT': {
                const count = this.toNumber(evalArg(0));
                const str = this.stringify(evalArg(1));
                return str.substring(str.length - count);
            }
            
            case 'LEFTOF': {
                const search = this.stringify(evalArg(0));
                const str = this.stringify(evalArg(1));
                const idx = str.indexOf(search);
                return idx >= 0 ? str.substring(0, idx) : str;
            }
            
            case 'RIGHTOF': {
                const search = this.stringify(evalArg(0));
                const str = this.stringify(evalArg(1));
                const idx = str.indexOf(search);
                return idx >= 0 ? str.substring(idx + search.length) : '';
            }
            
            case 'LEFTOFLAST': {
                const search = this.stringify(evalArg(0));
                const str = this.stringify(evalArg(1));
                const idx = str.lastIndexOf(search);
                return idx >= 0 ? str.substring(0, idx) : str;
            }
            
            case 'RIGHTOFLAST': {
                const search = this.stringify(evalArg(0));
                const str = this.stringify(evalArg(1));
                const idx = str.lastIndexOf(search);
                return idx >= 0 ? str.substring(idx + search.length) : '';
            }
            
            case 'LENGTH': {
                return this.stringify(evalArg(0)).length;
            }
            
            case 'LOWERCASE': {
                return this.stringify(evalArg(0)).toLowerCase();
            }
            
            case 'UPPERCASE': {
                return this.stringify(evalArg(0)).toUpperCase();
            }
            
            case 'TITLECASE': {
                return this.stringify(evalArg(0)).replace(/\w\S*/g, txt => 
                    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
                );
            }
            
            case 'TRIM': {
                return this.stringify(evalArg(0)).trim().replace(/\s+/g, ' ');
            }
            
            case 'REPLACE': {
                const search = this.stringify(evalArg(0));
                const replacement = this.stringify(evalArg(1));
                const str = this.stringify(evalArg(2));
                return str.split(search).join(replacement);
            }
            
            case 'REMOVECHARS': {
                const str = this.stringify(evalArg(0));
                const chars = this.stringify(evalArg(1));
                let result = str;
                for (const c of chars) {
                    result = result.split(c).join('');
                }
                return result;
            }
            
            case 'REMOVESPACES': {
                return this.stringify(evalArg(0)).replace(/\s/g, '');
            }
            
            case 'REMOVEDIACRITICS': {
                return this.stringify(evalArg(0)).normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            }
            
            case 'REMOVESYMBOLS': {
                return this.stringify(evalArg(0)).replace(/[^a-zA-Z0-9\s]/g, '');
            }
            
            case 'NORMALIZETEXT': {
                return this.stringify(evalArg(0)).replace(/\s+/g, '').replace(/<[^>]*>/g, '');
            }
            
            case 'PARSE': {
                const leftMarker = this.stringify(evalArg(0));
                const rightMarker = this.stringify(evalArg(1));
                const str = this.stringify(evalArg(2));
                const leftIdx = str.indexOf(leftMarker);
                if (leftIdx < 0) return '';
                const afterLeft = str.substring(leftIdx + leftMarker.length);
                const rightIdx = afterLeft.indexOf(rightMarker);
                return rightIdx >= 0 ? afterLeft.substring(0, rightIdx) : afterLeft;
            }
            
            case 'REGEXFIND': {
                try {
                    const pattern = this.stringify(evalArg(0));
                    const str = this.stringify(evalArg(1));
                    const regex = new RegExp(pattern);
                    const match = str.match(regex);
                    return match ? match[0] : '';
                } catch (e) {
                    return `[Regex error: ${e.message}]`;
                }
            }
            
            case 'REGEXWORDSONLY': {
                const text = this.stringify(evalArg(0));
                return text.split(/\s+/).map(w => w.replace(/[^a-zA-Z0-9]/g, '')).filter(w => w).join('|');
            }
            
            case 'URLENCODE': {
                return encodeURIComponent(this.stringify(evalArg(0)));
            }
            
            case 'ENCLOSE': {
                return this.stringify(evalArg(0));
            }
            
            // Number functions
            case 'CALC': {
                // Evaluate all parts and concatenate to form expression
                const exprParts = argNodes.map(n => this.stringify(this.evaluate(n)));
                const expr = exprParts.join('');
                try {
                    // Safe math evaluation (only basic operations)
                    const sanitized = expr.replace(/[^0-9+\-*/%().\s]/g, '');
                    return Function('"use strict"; return (' + sanitized + ')')();
                } catch (e) {
                    return `[Calc error: ${e.message}]`;
                }
            }
            
            case 'NUM': {
                const str = this.stringify(evalArg(0));
                const nums = str.match(/-?\d+\.?\d*/);
                return nums ? parseFloat(nums[0]) : 0;
            }
            
            case 'NUMSPLIT': {
                const str = this.stringify(evalArg(0));
                const nums = str.match(/-?\d+\.?\d*/g);
                return nums ? nums.join(';') : '';
            }
            
            case 'ROUND': {
                const decimals = this.toNumber(evalArg(0));
                const num = this.toNumber(evalArg(1));
                return Number(num.toFixed(decimals));
            }
            
            case 'FLOOR': {
                return Math.floor(this.toNumber(evalArg(0)));
            }
            
            case 'CEILING': {
                return Math.ceil(this.toNumber(evalArg(0)));
            }
            
            case 'MAX': {
                const nums = evalAllArgs().map(a => this.toNumber(a));
                return Math.max(...nums);
            }
            
            case 'MIN': {
                const nums = evalAllArgs().map(a => this.toNumber(a));
                return Math.min(...nums);
            }
            
            case 'SUM': {
                const nums = evalAllArgs().map(a => this.toNumber(a));
                return nums.reduce((sum, n) => sum + n, 0);
            }
            
            case 'RANDOMNUM': {
                const min = this.toNumber(evalArg(0));
                const max = this.toNumber(evalArg(1));
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            
            case 'PARTITION': {
                const num = this.toNumber(evalArg(0));
                const divisor = this.toNumber(evalArg(1));
                const parts = [];
                let remaining = num;
                while (remaining > 0) {
                    const part = Math.min(divisor, remaining);
                    parts.push(part);
                    remaining -= part;
                }
                return parts.join(';');
            }
            
            // Comparison functions
            case 'GTNUM': {
                return this.toNumber(evalArg(0)) > this.toNumber(evalArg(1)) ? 1 : 0;
            }
            
            case 'GTENUM': {
                return this.toNumber(evalArg(0)) >= this.toNumber(evalArg(1)) ? 1 : 0;
            }
            
            case 'LTNUM': {
                return this.toNumber(evalArg(0)) < this.toNumber(evalArg(1)) ? 1 : 0;
            }
            
            case 'LTENUM': {
                return this.toNumber(evalArg(0)) <= this.toNumber(evalArg(1)) ? 1 : 0;
            }
            
            case 'BENUM': {
                const num = this.toNumber(evalArg(0));
                const min = this.toNumber(evalArg(1));
                const max = this.toNumber(evalArg(2));
                return (num >= min && num <= max) ? 1 : 0;
            }
            
            // Logic functions
            case 'IF': {
                // Process condition-result pairs
                for (let i = 0; i < argNodes.length - 1; i += 2) {
                    const condition = this.toBoolean(evalArg(i));
                    if (condition) {
                        return evalArg(i + 1);
                    }
                }
                // Last argument is the else case (if odd number of args)
                if (argNodes.length % 2 === 1) {
                    return evalArg(argNodes.length - 1);
                }
                return '';
            }
            
            case 'HASVALUE': {
                const val = this.stringify(evalArg(0)).trim();
                return val !== '' ? 1 : 0;
            }
            
            case 'ISEMPTY': {
                const val = this.stringify(evalArg(0)).trim();
                return val === '' ? 1 : 0;
            }
            
            case 'ISTRUE': {
                return evalAllArgs().every(a => this.toBoolean(a)) ? 1 : 0;
            }
            
            case 'ANYTRUE': {
                return evalAllArgs().some(a => this.toBoolean(a)) ? 1 : 0;
            }
            
            case 'NOT': {
                return this.toBoolean(evalArg(0)) ? 0 : 1;
            }
            
            case 'FIRSTVALUE': {
                for (const node of argNodes) {
                    const val = this.stringify(this.evaluate(node)).trim();
                    if (val !== '') return val;
                }
                return '';
            }
            
            // List functions
            case 'SPLIT': {
                const delimiter = this.stringify(evalArg(0));
                const index = this.toNumber(evalArg(1));
                const str = this.stringify(evalArg(2));
                const parts = str.split(delimiter);
                if (index === 0) return parts.join(';');
                return parts[index - 1] || '';
            }
            
            case 'LISTCOUNT': {
                const args = evalAllArgs();
                // If single argument with semicolons, split it
                if (args.length === 1) {
                    return this.stringify(args[0]).split(';').filter(s => s.trim()).length;
                }
                return args.filter(a => this.stringify(a).trim()).length;
            }
            
            case 'LISTINDEX': {
                const index = this.toNumber(evalArg(0));
                const list = this.stringify(evalArg(1)).split(';');
                if (index === 0) return list.join(';');
                return list[index - 1] || '';
            }
            
            case 'LISTJOIN': {
                let separator = this.stringify(evalArg(0));
                // Handle special keywords
                separator = separator
                    .replace(/ppnewline/gi, '\n')
                    .replace(/ppcrlf/gi, '\r\n')
                    .replace(/pptab/gi, '\t')
                    .replace(/ppsp/gi, ' ');
                const list = this.stringify(evalArg(1)).split(';');
                return list.join(separator);
            }
            
            case 'LISTMERGE': {
                const list1 = this.stringify(evalArg(0)).split(';').filter(s => s);
                const list2 = this.stringify(evalArg(1)).split(';').filter(s => s);
                return [...new Set([...list1, ...list2])].join(';');
            }
            
            case 'LISTDIFF': {
                const list1 = this.stringify(evalArg(0)).split(';').filter(s => s);
                const list2 = new Set(this.stringify(evalArg(1)).split(';').filter(s => s));
                return list1.filter(item => !list2.has(item)).join(';');
            }
            
            case 'LISTINTERSECT': {
                const list1 = this.stringify(evalArg(0)).split(';').filter(s => s);
                const list2 = new Set(this.stringify(evalArg(1)).split(';').filter(s => s));
                return list1.filter(item => list2.has(item)).join(';');
            }
            
            case 'LISTUNIQUE': {
                const list = this.stringify(evalArg(0)).split(';').filter(s => s);
                return [...new Set(list)].join(';');
            }
            
            case 'LISTASLINES': {
                return this.stringify(evalArg(0)).split(';').join('\n');
            }
            
            case 'LINESPLIT': {
                const index = this.toNumber(evalArg(0));
                const lines = this.stringify(evalArg(1)).split(/\r?\n/);
                if (index === 0) return lines.join(';');
                return lines[index - 1] || '';
            }
            
            case 'WORDSPLIT': {
                const index = this.toNumber(evalArg(0));
                const words = this.stringify(evalArg(1)).split(/\s+/).filter(w => w);
                if (index === 0) return words.join(';');
                return words[index - 1] || '';
            }
            
            case 'EMAILSPLIT': {
                const index = this.toNumber(evalArg(0));
                const text = this.stringify(evalArg(1));
                const emails = text.match(/[^\s,;]+@[^\s,;]+/g) || [];
                if (index === 0) return emails.join(';');
                return emails[index - 1] || '';
            }
            
            case 'LISTITEMAPPEND': {
                const append = this.stringify(evalArg(0));
                const list = this.stringify(evalArg(1)).split(';');
                return list.map(item => item + append).join(';');
            }
            
            case 'LISTITEMPREPEND': {
                const prepend = this.stringify(evalArg(0));
                const list = this.stringify(evalArg(1)).split(';');
                return list.map(item => prepend + item).join(';');
            }
            
            case 'LISTITEMCONTAINS': {
                const search = this.stringify(evalArg(0)).toLowerCase();
                const list = this.stringify(evalArg(1)).split(';');
                return list.filter(item => item.toLowerCase().includes(search)).join(';');
            }
            
            case 'LISTITEMSTARTSWITH': {
                const search = this.stringify(evalArg(0)).toLowerCase();
                const list = this.stringify(evalArg(1)).split(';');
                return list.filter(item => item.toLowerCase().startsWith(search)).join(';');
            }
            
            case 'LISTITEMENDSWITH': {
                const search = this.stringify(evalArg(0)).toLowerCase();
                const list = this.stringify(evalArg(1)).split(';');
                return list.filter(item => item.toLowerCase().endsWith(search)).join(';');
            }
            
            case 'LISTITEMLEFT': {
                const count = this.toNumber(evalArg(0));
                const list = this.stringify(evalArg(1)).split(';');
                return list.map(item => item.substring(0, count)).join(';');
            }
            
            case 'LISTITEMRIGHT': {
                const count = this.toNumber(evalArg(0));
                const list = this.stringify(evalArg(1)).split(';');
                return list.map(item => item.substring(item.length - count)).join(';');
            }
            
            case 'LISTITEMLEFTOF': {
                const search = this.stringify(evalArg(0));
                const list = this.stringify(evalArg(1)).split(';');
                return list.map(item => {
                    const idx = item.indexOf(search);
                    return idx >= 0 ? item.substring(0, idx) : item;
                }).join(';');
            }
            
            case 'LISTITEMRIGHTOF': {
                const search = this.stringify(evalArg(0));
                const list = this.stringify(evalArg(1)).split(';');
                return list.map(item => {
                    const idx = item.indexOf(search);
                    return idx >= 0 ? item.substring(idx + search.length) : '';
                }).join(';');
            }
            
            case 'LISTITEMREGEX': {
                try {
                    const pattern = this.stringify(evalArg(0));
                    const list = this.stringify(evalArg(1)).split(';');
                    const regex = new RegExp(pattern);
                    return list.filter(item => regex.test(item)).join(';');
                } catch (e) {
                    return `[Regex error: ${e.message}]`;
                }
            }
            
            // Date functions
            case 'YEAR': {
                const d = this.parseDate(evalArg(0));
                return d ? d.getFullYear() : 0;
            }
            
            case 'MONTH': {
                const d = this.parseDate(evalArg(0));
                return d ? d.getMonth() + 1 : 0;
            }
            
            case 'MONTHDAY': {
                const d = this.parseDate(evalArg(0));
                return d ? d.getDate() : 0;
            }
            
            case 'DATEPART': {
                const part = this.stringify(evalArg(0)).toLowerCase();
                const d = this.parseDate(evalArg(1));
                if (!d) return 0;
                switch (part) {
                    case 'year': return d.getFullYear();
                    case 'month': return d.getMonth() + 1;
                    case 'day': return d.getDate();
                    case 'weekday': return d.getDay();
                    case 'hour': return d.getHours();
                    case 'minute': return d.getMinutes();
                    case 'second': return d.getSeconds();
                    case 'yearday': return Math.ceil((d - new Date(d.getFullYear(), 0, 1)) / 86400000) + 1;
                    default: return 0;
                }
            }
            
            case 'DATESERIAL': {
                const year = this.toNumber(evalArg(0));
                const month = this.toNumber(evalArg(1)) - 1;
                const day = this.toNumber(evalArg(2));
                const d = new Date(year, month, day);
                return d.toISOString().split('T')[0];
            }
            
            case 'DATEDIFF': {
                const unit = this.stringify(evalArg(0)).toLowerCase();
                const d1 = this.parseDate(evalArg(1));
                const d2 = this.parseDate(evalArg(2));
                if (!d1 || !d2) return 0;
                const diffMs = d2 - d1;
                switch (unit) {
                    case 'second': return Math.floor(diffMs / 1000);
                    case 'minute': return Math.floor(diffMs / 60000);
                    case 'hour': return Math.floor(diffMs / 3600000);
                    case 'day': return Math.floor(diffMs / 86400000);
                    case 'week': return Math.floor(diffMs / 604800000);
                    case 'month': return (d2.getFullYear() - d1.getFullYear()) * 12 + (d2.getMonth() - d1.getMonth());
                    case 'year': return d2.getFullYear() - d1.getFullYear();
                    default: return Math.floor(diffMs / 86400000);
                }
            }
            
            case 'DATEADD': {
                const unit = this.stringify(evalArg(0)).toLowerCase();
                const amount = this.toNumber(evalArg(1));
                const d = this.parseDate(evalArg(2));
                if (!d) return '';
                const result = new Date(d);
                switch (unit) {
                    case 'second': result.setSeconds(result.getSeconds() + amount); break;
                    case 'minute': result.setMinutes(result.getMinutes() + amount); break;
                    case 'hour': result.setHours(result.getHours() + amount); break;
                    case 'day': result.setDate(result.getDate() + amount); break;
                    case 'weekday': {
                        const sign = Math.sign(amount) || 1;
                        const abs = Math.abs(amount);
                        const fullWeeks = Math.floor(abs / 5);
                        const remainder = abs % 5;
                        // Step 1: add full workweeks
                        result.setDate(result.getDate() + sign * fullWeeks * 7);
                        // Step 2: handle remainder
                        let dow = result.getDay();
                        // Normalize weekday index (Mon=0 ... Fri=4)
                        const weekdayIndex =
                            dow === 0 ? -1 :
                            dow === 6 ? -2 :
                            dow - 1;
                        let extraDays = remainder;
                        // Crossing weekend?
                        if (weekdayIndex + remainder >= 5) {
                            extraDays += 2;
                        }
                        result.setDate(result.getDate() + sign * extraDays);
                        break;
                    }
                    case 'week': result.setDate(result.getDate() + (amount * 7)); break;
                    case 'month': result.setMonth(result.getMonth() + amount); break;
                    case 'year': result.setFullYear(result.getFullYear() + amount); break;
                }
                return result.toISOString().split('T')[0];
            }
            
            case 'DATELIST': {
                const d1 = this.parseDate(evalArg(0));
                const d2 = this.parseDate(evalArg(1));
                if (!d1 || !d2) return '';
                const dates = [];
                const current = new Date(d1);
                while (current <= d2) {
                    dates.push(current.toISOString().split('T')[0]);
                    current.setDate(current.getDate() + 1);
                }
                return dates.join(';');
            }
            
            case 'DATETIMEMERGE': {
                const dateStr = this.stringify(evalArg(0));
                const timeStr = this.stringify(evalArg(1));
                return `${dateStr} ${timeStr}`;
            }
            
            case 'DATEROUND': {
                const unit = this.stringify(evalArg(0)).toLowerCase();
                const interval = this.toNumber(evalArg(1));
                const d = this.parseDate(evalArg(2));
                if (!d) return '';
                // Simplified rounding
                return d.toISOString().split('T')[0];
            }
            
            case 'GTDATE': {
                const d1 = this.parseDate(evalArg(0));
                const d2 = this.parseDate(evalArg(1));
                return (d1 && d2 && d1 > d2) ? 1 : 0;
            }
            
            case 'GTEDATE': {
                const d1 = this.parseDate(evalArg(0));
                const d2 = this.parseDate(evalArg(1));
                return (d1 && d2 && d1 >= d2) ? 1 : 0;
            }
            
            case 'LTDATE': {
                const d1 = this.parseDate(evalArg(0));
                const d2 = this.parseDate(evalArg(1));
                return (d1 && d2 && d1 < d2) ? 1 : 0;
            }
            
            case 'LTEDATE': {
                const d1 = this.parseDate(evalArg(0));
                const d2 = this.parseDate(evalArg(1));
                return (d1 && d2 && d1 <= d2) ? 1 : 0;
            }
            
            case 'BDATE': {
                const d = this.parseDate(evalArg(0));
                const d1 = this.parseDate(evalArg(1));
                const d2 = this.parseDate(evalArg(2));
                return (d && d1 && d2 && d > d1 && d < d2) ? 1 : 0;
            }
            
            case 'MONTHLASTDAY': {
                const d = this.parseDate(evalArg(0));
                if (!d) return '';
                const offset = argNodes.length > 1 ? this.toNumber(evalArg(1)) : 0;
                const lastDay = new Date(d.getFullYear(), d.getMonth() + 1, 0);
                lastDay.setDate(lastDay.getDate() + offset);
                return lastDay.toISOString().split('T')[0];
            }
            
            case 'FISCALMONTH': {
                const startMonth = this.toNumber(evalArg(0));
                const d = this.parseDate(evalArg(1));
                if (!d) return 0;
                const month = d.getMonth() + 1;
                let fiscalMonth = month - startMonth + 1;
                if (fiscalMonth <= 0) fiscalMonth += 12;
                return fiscalMonth;
            }
            
            case 'FISCALYEAR': {
                const startMonth = this.toNumber(evalArg(0));
                const d = this.parseDate(evalArg(1));
                if (!d) return 0;
                const month = d.getMonth() + 1;
                let year = d.getFullYear();
                if (month < startMonth) year--;
                return year;
            }
            
            // JSON functions
            case 'JSONENCODE': {
                return JSON.stringify(this.stringify(evalArg(0)));
            }
            
            case 'JSONEXTRACT': {
                const str = this.stringify(evalArg(0));
                const match = str.match(/[\[{].*[\]}]/s);
                return match ? match[0] : '';
            }
            
            case 'JSONQUERY': {
                const path = this.stringify(evalArg(0));
                const jsonStr = this.stringify(evalArg(1));
                try {
                    const obj = JSON.parse(jsonStr);
                    const parts = path.split('.');
                    let current = obj;
                    for (const part of parts) {
                        if (current === null || current === undefined) return '';
                        current = current[part];
                    }
                    return typeof current === 'object' ? JSON.stringify(current) : this.stringify(current);
                } catch (e) {
                    return `[JSON error: ${e.message}]`;
                }
            }
            
            case 'JSONUPDATE': {
                const jsonStr = this.stringify(evalArg(0));
                const prop = this.stringify(evalArg(1));
                const value = evalArg(2);
                try {
                    const obj = jsonStr ? JSON.parse(jsonStr) : {};
                    obj[prop] = value;
                    return JSON.stringify(obj);
                } catch (e) {
                    return `[JSON error: ${e.message}]`;
                }
            }
            
            case 'JSONINDEX': {
                const index = this.toNumber(evalArg(0));
                const jsonStr = this.stringify(evalArg(1));
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!Array.isArray(arr)) return '';
                    const idx = index < 0 ? arr.length + index : index;
                    const item = arr[idx];
                    return typeof item === 'object' ? JSON.stringify(item) : this.stringify(item);
                } catch (e) {
                    return `[JSON error: ${e.message}]`;
                }
            }
            
            case 'JSONREMOVE': {
                const index = this.toNumber(evalArg(0));
                const jsonStr = this.stringify(evalArg(1));
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!Array.isArray(arr)) return jsonStr;
                    arr.splice(index, 1);
                    return JSON.stringify(arr);
                } catch (e) {
                    return `[JSON error: ${e.message}]`;
                }
            }
            
            case 'JSONFIFO': {
                const jsonStr = this.stringify(evalArg(0));
                const newItem = evalArg(1);
                const maxLen = this.toNumber(evalArg(2));
                try {
                    let arr = jsonStr ? JSON.parse(jsonStr) : [];
                    if (!Array.isArray(arr)) arr = [];
                    arr.unshift(typeof newItem === 'string' ? JSON.parse(newItem) : newItem);
                    if (maxLen > 0 && arr.length > maxLen) {
                        arr = arr.slice(0, maxLen);
                    }
                    return JSON.stringify(arr);
                } catch (e) {
                    return `[JSON error: ${e.message}]`;
                }
            }
            
            case 'FORMAT': {
                const format = this.stringify(evalArg(0));
                const value = evalArg(1);
                // Try to format as number
                const num = this.toNumber(value);
                if (!isNaN(num)) {
                    // Count decimal places in format
                    const decimalMatch = format.match(/\.(\d+)/);
                    const decimals = decimalMatch ? decimalMatch[1].length : 0;
                    return num.toFixed(decimals);
                }
                // Try to format as date
                const d = this.parseDate(value);
                if (d) {
                    return d.toLocaleDateString();
                }
                return this.stringify(value);
            }
            
            default:
                return `[Unknown function: ${name}]`;
        }
    }
}

// Main compile function
function compileFormula() {
    const code = textarea.value;
    const outputEl = document.getElementById('compilerOutput');
    
    if (!code.trim()) {
        outputEl.textContent = 'Enter a formula to compile...';
        outputEl.className = 'output-box';
        return;
    }
    
    // Strip comments first
    const cleanCode = stripComments(code);
    
    try {
        // Tokenize
        const tokens = compilerTokenize(cleanCode);
        
        // Parse into AST
        const parser = new FormulaParser(tokens);
        const ast = parser.parse();
        
        // Evaluate
        const evaluator = new FormulaEvaluator(fieldValues);
        const result = evaluator.evaluate(ast);
        
        outputEl.textContent = evaluator.stringify(result);
        outputEl.className = 'output-box success';
        showNotification('Formula compiled successfully!');
    } catch (error) {
        outputEl.textContent = `Error: ${error.message}`;
        outputEl.className = 'output-box error';
        showNotification('Compilation error', 'error');
    }
}

// Toggle function status display
function toggleFunctionStatus() {
    const container = document.getElementById('functionStatusContainer');
    const toggle = document.querySelector('.function-status-toggle');
    container.classList.toggle('show');
    toggle.textContent = container.classList.contains('show') ? 'Hide Details' : 'Show Details';
}

// Render function status grid
function renderFunctionStatus() {
    const summaryEl = document.getElementById('functionStatusSummary');
    const gridEl = document.getElementById('functionStatusGrid');
    
    let implemented = 0, partial = 0, notImplemented = 0;
    
    const items = Object.entries(FUNCTION_STATUS).map(([name, status]) => {
        if (status === 'implemented') implemented++;
        else if (status === 'partial') partial++;
        else notImplemented++;
        
        const icon = status === 'implemented' ? '‚úì' : status === 'partial' ? '‚óê' : '‚úó';
        return `<div class="function-status-item ${status}"><span class="status-icon">${icon}</span>${name}</div>`;
    });
    
    summaryEl.innerHTML = `
        <div class="status-count implemented">‚úì ${implemented} Implemented</div>
        <div class="status-count partial">‚óê ${partial} Partial</div>
        <div class="status-count not-implemented">‚úó ${notImplemented} Not Available</div>
    `;
    
    gridEl.innerHTML = items.join('');
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Function documentation
// Function documentation (from official ProcessPlan documentation)
const FUNCTION_DOCS = [
    { name: '!CONTAINS', syntax: '=!CONTAINS(DoesThisValueNotExist; AnywhereInsideThisValue)', description: 'Returns true if a search text is NOT found within some other text.', example: '=!CONTAINS(SearchText; [[Field]])' },
    { name: '!EQUALS', syntax: '=!EQUALS(DoesThisValue; NotEqualThisValue; OrThisValue; ...)', description: 'Returns true if the first value does NOT equal any of the other values.', example: '=!EQUALS([[Status]]; Approved; Complete)' },
    { name: 'ANYTRUE', syntax: '=ANYTRUE(IsThisFunctionTrue; IsThisFunctionTrue; ...)', description: 'Returns 1 (true) if ANY parameter returns true. Numbers > 0 are true.', example: '=ANYTRUE(=EQUALS([[Status]]; Complete); =GTNUM([[Score]]; 80))' },
    { name: 'APPEND', syntax: '=APPEND(Separator; Item1; Item2; ...)', description: 'Combines values together with a specified separator character.', example: '[[FirstName]]=APPEND( ; [[LastName]])' },
    { name: 'BDATE', syntax: '=BDATE(IsThisDate; GreaterThanThisDate; AndLessThanThisDate)', description: 'Returns 1 if the date is between two other dates (exclusive), 0 if false.', example: '=BDATE([[DueDate]]; 2024-01-01; 2024-12-31)' },
    { name: 'BENUM', syntax: '=BENUM(IsThisNum; GreaterThanOrEqualToThisNum; AndLessThanOrEqualToThisNum)', description: 'Returns 1 if number is between or equal to two numbers (inclusive).', example: '=BENUM([[Score]]; 0; 100)' },
    { name: 'CALC', syntax: '=CALC(MathematicalExpression)', description: 'Performs mathematical operations on numbers or numeric fields.', example: '=CALC([[Price]] * [[Quantity]])' },
    { name: 'CEILING', syntax: '=CEILING(AnyNumber)', description: 'Returns the smallest integer >= the specified number.', example: '=CEILING(4.2)' },
    { name: 'CONTAINS', syntax: '=CONTAINS(DoesThisValueExist; AnywhereInsideThisValue)', description: 'Returns true if search text is found within other text.', example: '=CONTAINS(urgent; [[Description]])' },
    { name: 'DATEADD', syntax: '=DATEADD(UnitToIncrement; IncrementBy; DateToIncrement; OptionalMinDate)', description: 'Adds/subtracts time from a date. Units: minute, hour, workhour, day, weekday, week, month, year.', example: '=DATEADD(day; 30; [[StartDate]])' },
    { name: 'DATEDIFF', syntax: '=DATEDIFF(ReturnUnit; SubtractThisDate; FromThisDate)', description: 'Returns difference between two dates in specified unit.', example: '=DATEDIFF(day; [[StartDate]]; [[EndDate]])' },
    { name: 'DATELIST', syntax: '=DATELIST(StartDate; EndDate)', description: 'Generates semicolon-separated list of consecutive dates (inclusive).', example: '=DATELIST(2024-01-01; 2024-01-31)' },
    { name: 'DATEPART', syntax: '=DATEPART(DatePart; DateValue)', description: 'Extracts numeric part from date: year, weekday, yearday, monthweek, yearweek, month, day, hour, minute, second.', example: '=DATEPART(weekday; [[CreatedDate]])' },
    { name: 'DATEPATTERN', syntax: '=DATEPATTERN(DateRecurrencePattern; EndDateToGenerate; RecurrenceAnchorDate; StartFromStartDate)', description: 'Generates future dates based on recurrence pattern. Supports weekly, bi-weekly, monthly with exclusions.', example: '=DATEPATTERN(f1w d{12345}; 2024-12-31)' },
    { name: 'DATEROUND', syntax: '=DATEROUND(UnitToRoundTo; IntervalNum; DateToRound)', description: 'Rounds date/time to nearest interval. Units: minute, hour, day.', example: '=DATEROUND(hour; 1; [[Timestamp]])' },
    { name: 'DATESERIAL', syntax: '=DATESERIAL(Year; Month; Day)', description: 'Creates a date from year, month, day components.', example: '=DATESERIAL(2024; 12; 25)' },
    { name: 'DATETIMEMERGE', syntax: '=DATETIMEMERGE(DateValue; TimeValue)', description: 'Merges date and time into single date/time value.', example: '=DATETIMEMERGE([[DateField]]; [[TimeField]])' },
    { name: 'EMAILSPLIT', syntax: '=EMAILSPLIT(ReturnIndex; EmailAddressText)', description: 'Splits emails into semicolon list. Index 0 returns all.', example: '=EMAILSPLIT(0; email1@test.com, email2@test.com)' },
    { name: 'ENCLOSE', syntax: '=ENCLOSE(ValueYouWantToHide)', description: 'Hides text from rest of function. Useful for tokens with semicolons/HTML.', example: '=ENCLOSE([[FieldWithSemicolons]])' },
    { name: 'EQUALS', syntax: '=EQUALS(DoesThisValue; EqualThisValue; AndThisValue; ...)', description: 'Returns true if first value equals ALL other values.', example: '=EQUALS([[Status]]; Approved)' },
    { name: 'FIRSTVALUE', syntax: '=FIRSTVALUE(Item1; Item2; Item3; ...)', description: 'Returns first non-empty value from list.', example: '=FIRSTVALUE([[PreferredName]]; [[FirstName]]; Unknown)' },
    { name: 'FISCALMONTH', syntax: '=FISCALMONTH(FiscalYearStartMonthNumber; DateToEvaluate)', description: 'Returns fiscal month number based on fiscal year start.', example: '=FISCALMONTH(7; [[Date]])' },
    { name: 'FISCALYEAR', syntax: '=FISCALYEAR(FiscalYearStartMonthNumber; DateToEvaluate)', description: 'Returns fiscal year based on fiscal year start month.', example: '=FISCALYEAR(7; [[Date]])' },
    { name: 'FLOOR', syntax: '=FLOOR(AnyNumber)', description: 'Returns largest integer <= the specified number.', example: '=FLOOR(4.8)' },
    { name: 'FORMAT', syntax: '=FORMAT(FormatString; NumberOrDate)', description: 'Formats number/date according to format string.', example: '=FORMAT(0.00; [[Price]])' },
    { name: 'GTDATE', syntax: '=GTDATE(IsThisDate; GreaterThanThisDate)', description: 'Returns 1 if first date > second date, 0 if false.', example: '=GTDATE([[DueDate]]; [[Today]])' },
    { name: 'GTEDATE', syntax: '=GTEDATE(Date1; Date2)', description: 'Returns 1 if Date1 >= Date2, 0 if false.', example: '=GTEDATE([[EndDate]]; [[StartDate]])' },
    { name: 'GTENUM', syntax: '=GTENUM(IsThisNumber; GreaterOrEqualToThisNumber)', description: 'Returns 1 if first number >= second, 0 if false.', example: '=GTENUM([[Score]]; 70)' },
    { name: 'GTNUM', syntax: '=GTNUM(IsThisNumber; GreaterThanThisNumber)', description: 'Returns 1 if first number > second, 0 if false.', example: '=GTNUM([[Total]]; 1000)' },
    { name: 'HASVALUE', syntax: '=HASVALUE(DoesAnyValueExistHere)', description: 'Returns true if any value exists (not empty).', example: '=HASVALUE([[Comments]])' },
    { name: 'IF', syntax: '=IF(ConditionCheck; IfTrueReturnThis; AnotherCondition OR IfFalseReturnThis; IfTrueReturnThis; OptionalIfFalse)', description: 'Checks conditions, returns corresponding values. First true wins.', example: '=IF(=GTNUM([[Score]]; 70); Pass; Fail)' },
    { name: 'INSTANCECOUNT', syntax: '=INSTANCECOUNT(TableID; TableQuery)', description: 'Returns count of instances matching query.', example: '=INSTANCECOUNT(TableID; tf_id_xxx[eq]Value)' },
    { name: 'INSTANCETASKCOUNT', syntax: '=INSTANCETASKCOUNT(ProcessInstanceID; TemplateTaskID)', description: 'Returns times a task was assigned in a process instance.', example: '=INSTANCETASKCOUNT([[ProcessInstanceID]]; TaskID)' },
    { name: 'INSTANCEUPDATE', syntax: '=INSTANCEUPDATE(FieldIDToUpdate; TableIDToSearch; SearchQuery; NewFieldValue)', description: 'Updates field in processes matching query.', example: '=INSTANCEUPDATE(FieldID; TableID; Query; NewValue)' },
    { name: 'ISCONTEXT', syntax: '=ISCONTEXT(ContextIDToTest; AnotherOptionalID; ...)', description: 'Tests if formula runs in specified context (User, Group, Task, Form, etc.). Returns 1 if true.', example: '=IF(=ISCONTEXT(FormID); Atlanta; Orlando)' },
    { name: 'ISEMPTY', syntax: '=ISEMPTY(IsTheValueEmpty)', description: 'Returns true if field is empty.', example: '=ISEMPTY([[Notes]])' },
    { name: 'ISPUBLICUSER', syntax: '=ISPUBLICUSER()', description: 'Returns true if executed by non-logged-in user.', example: '=IF(=ISPUBLICUSER(); PublicContent; PrivateContent)' },
    { name: 'ISTRUE', syntax: '=ISTRUE(IsThisTrue; OptionalIsThisTrue; ...)', description: 'Returns true if ALL values are true. Numbers > 0 are true.', example: '=ISTRUE([[IsActive]]; [[IsVerified]])' },
    { name: 'JSONENCODE', syntax: '=JSONENCODE(TextParameter)', description: 'Returns text JSON encoded for use as JSON property value.', example: '=JSONENCODE([[MultilineText]])' },
    { name: 'JSONEXTRACT', syntax: '=JSONEXTRACT(AnyTextContainingJSON)', description: 'Extracts first valid JSON object/array from text.', example: '=JSONEXTRACT([[APIResponse]])' },
    { name: 'JSONFIFO', syntax: '=JSONFIFO(ExistingJsonArray; NewJsonObjectToAdd; MaximumLength)', description: 'Adds JSON object to array. If MaxLength exceeded, removes last. Use 0 for no max.', example: '=JSONFIFO([[LogArray]]; {"action":"login"}; 100)' },
    { name: 'JSONINDEX', syntax: '=JSONINDEX(IndexToRetrieve; ExistingJsonArray)', description: 'Returns element at index. Positive from start, negative from end.', example: '=JSONINDEX(1; [[JsonArray]])' },
    { name: 'JSONQUERY', syntax: '=JSONQUERY(JSONPropertyName; JSONContainingTheProperty)', description: 'Queries JSON and extracts property values. Use dot notation for nested.', example: '=JSONQUERY(data.name; [[JsonField]])' },
    { name: 'JSONREMOVE', syntax: '=JSONREMOVE(IndexToRemove; ExistingJsonArray)', description: 'Removes element at index and returns modified array.', example: '=JSONREMOVE(1; [[JsonArray]])' },
    { name: 'JSONUPDATE', syntax: '=JSONUPDATE(ExistingJsonObject; PropertyName; PropertyValue)', description: 'Adds or updates property in JSON object.', example: '=JSONUPDATE([[JsonObject]]; status; updated)' },
    { name: 'LEFT', syntax: '=LEFT(Count; Value)', description: 'Returns specified characters from start of string.', example: '=LEFT(3; [[Code]])' },
    { name: 'LEFTOF', syntax: '=LEFTOF(ReturnLeftOf; SearchInString)', description: 'Returns text left of first occurrence of characters.', example: '=LEFTOF(@; [[Email]])' },
    { name: 'LEFTOFLAST', syntax: '=LEFTOFLAST(ReturnLeftOf; SearchInString)', description: 'Returns text left of LAST occurrence.', example: '=LEFTOFLAST(/; [[FilePath]])' },
    { name: 'LENGTH', syntax: '=LENGTH(CharacterString)', description: 'Returns character count in string.', example: '=LENGTH([[Description]])' },
    { name: 'LINESPLIT', syntax: '=LINESPLIT(IndexOfSplitListToReturn; TextToSplit)', description: 'Splits multiline text into list. Index 0 returns all.', example: '=LINESPLIT(1; [[Address]])' },
    { name: 'LISTASLINES', syntax: '=LISTASLINES(SemicolonSeparatedList)', description: 'Converts list to text with each entry on separate line. Use ppcrlf for plain text.', example: '=LISTASLINES([[Items]])' },
    { name: 'LISTCOUNT', syntax: '=LISTCOUNT(Item1; Item2; ...)', description: 'Returns total items in list.', example: '=LISTCOUNT([[Tags]])' },
    { name: 'LISTDIFF', syntax: '=LISTDIFF(SemicolonSeparatedList1; SemicolonSeparatedList2)', description: 'Returns first list minus second list entries.', example: '=LISTDIFF([[AllItems]]; [[CompletedItems]])' },
    { name: 'LISTINDEX', syntax: '=LISTINDEX(ReturnIndex; SemicolonSeparatedTextList)', description: 'Returns entry at specified index.', example: '=LISTINDEX(2; [[Options]])' },
    { name: 'LISTINTERSECT', syntax: '=LISTINTERSECT(SemicolonSeparatedList1; SemicolonSeparatedList2)', description: 'Returns entries appearing in both lists.', example: '=LISTINTERSECT([[Skills]]; [[Required]])' },
    { name: 'LISTITEMAPPEND', syntax: '=LISTITEMAPPEND(AppendText; SemicolonSeparatedList)', description: 'Appends text to each list entry.', example: '=LISTITEMAPPEND(.pdf; [[Filenames]])' },
    { name: 'LISTITEMCONTAINS', syntax: '=LISTITEMCONTAINS(SearchForText; SemicolonSeparatedList)', description: 'Returns entries containing search text.', example: '=LISTITEMCONTAINS(error; [[LogEntries]])' },
    { name: 'LISTITEMENDSWITH', syntax: '=LISTITEMENDSWITH(SearchForText; SemicolonSeparatedList)', description: 'Returns entries ending with text.', example: '=LISTITEMENDSWITH(.pdf; [[Files]])' },
    { name: 'LISTITEMLEFT', syntax: '=LISTITEMLEFT(NumberOfCharsToReturn; SemicolonSeparatedList)', description: 'Returns leftmost chars from each entry.', example: '=LISTITEMLEFT(4; [[Codes]])' },
    { name: 'LISTITEMLEFTOF', syntax: '=LISTITEMLEFTOF(SearchForText; SemicolonSeparatedList)', description: 'Returns text left of search text for each entry.', example: '=LISTITEMLEFTOF(@; [[Emails]])' },
    { name: 'LISTITEMPREPEND', syntax: '=LISTITEMPREPEND(PrependText; SemicolonSeparatedList)', description: 'Prepends text to each list entry.', example: '=LISTITEMPREPEND(ID-; [[Numbers]])' },
    { name: 'LISTITEMREGEX', syntax: '=LISTITEMREGEX(RegEx; SemicolonSeparatedList)', description: 'Returns entries matching regex.', example: '=LISTITEMREGEX(.*Entry\\d; [[Items]])' },
    { name: 'LISTITEMRIGHT', syntax: '=LISTITEMRIGHT(NumberOfCharsToReturn; SemicolonSeparatedList)', description: 'Returns rightmost chars from each entry.', example: '=LISTITEMRIGHT(4; [[Files]])' },
    { name: 'LISTITEMRIGHTOF', syntax: '=LISTITEMRIGHTOF(SearchForText; SemicolonSeparatedList)', description: 'Returns text right of search text for each entry.', example: '=LISTITEMRIGHTOF(@; [[Emails]])' },
    { name: 'LISTITEMSTARTSWITH', syntax: '=LISTITEMSTARTSWITH(SearchForText; SemicolonSeparatedList)', description: 'Returns entries starting with text.', example: '=LISTITEMSTARTSWITH(A; [[Codes]])' },
    { name: 'LISTJOIN', syntax: '=LISTJOIN(NewListItemSeparator; SemicolonSeparatedList)', description: 'Joins entries with separator. Keywords: ppnewline, pptab, ppcrlf, ppsp.', example: '=LISTJOIN(ppnewline; [[Items]])' },
    { name: 'LISTMERGE', syntax: '=LISTMERGE(SemicolonSeparatedList1; SemicolonSeparatedList2)', description: 'Returns all unique entries from both lists.', example: '=LISTMERGE([[List1]]; [[List2]])' },
    { name: 'LISTUNIQUE', syntax: '=LISTUNIQUE(SemicolonSeparatedList)', description: 'Returns unique entries only (removes duplicates).', example: '=LISTUNIQUE([[AllTags]])' },
    { name: 'LOWERCASE', syntax: '=LOWERCASE(String)', description: 'Converts string to lowercase.', example: '=LOWERCASE([[Name]])' },
    { name: 'LTDATE', syntax: '=LTDATE(IsThisDate; LessThanThisDate)', description: 'Returns 1 if first date < second date, 0 if false.', example: '=LTDATE([[Created]]; [[Deadline]])' },
    { name: 'LTEDATE', syntax: '=LTEDATE(IsThisDate; LessThanOrEqualToThisDate)', description: 'Returns 1 if first date <= second date, 0 if false.', example: '=LTEDATE([[Start]]; [[End]])' },
    { name: 'LTENUM', syntax: '=LTENUM(Value1; Value2)', description: 'Returns 1 if first value <= second, 0 if false.', example: '=LTENUM([[Count]]; 10)' },
    { name: 'LTNUM', syntax: '=LTNUM(IsThisValue; LessThanThisValue)', description: 'Returns 1 if first value < second, 0 if false.', example: '=LTNUM([[Age]]; 18)' },
    { name: 'MAX', syntax: '=MAX(Parameter1; Parameter2; ...)', description: 'Returns maximum number from list.', example: '=MAX([[Score1]]; [[Score2]]; [[Score3]])' },
    { name: 'MIN', syntax: '=MIN(Parameter1; Parameter2; ...)', description: 'Returns minimum number from list.', example: '=MIN([[Price1]]; [[Price2]])' },
    { name: 'MONTH', syntax: '=MONTH(DateValue)', description: 'Extracts month (1-12) from date.', example: '=MONTH([[CreatedDate]])' },
    { name: 'MONTHDAY', syntax: '=MONTHDAY(DateValue)', description: 'Extracts day of month (1-31) from date.', example: '=MONTHDAY([[Birthday]])' },
    { name: 'MONTHLASTDAY', syntax: '=MONTHLASTDAY(DateValue; OptionalAddOrSubtractDay)', description: 'Returns last day of month. Optional param adds/subtracts days.', example: '=MONTHLASTDAY([[InvoiceDate]]; -1)' },
    { name: 'NORMALIZETEXT', syntax: '=NORMALIZETEXT(TextValue)', description: 'Removes spaces, formatting, HTML, carriage returns, line feeds.', example: '=NORMALIZETEXT([[Input]])' },
    { name: 'NOT', syntax: '=NOT(BooleanParameter)', description: 'Returns opposite of Boolean (True->False). Zero is false.', example: '=NOT(=ISEMPTY([[Field]]))' },
    { name: 'NUM', syntax: '=NUM(Parameter)', description: 'Extracts number by stripping non-numeric chars.', example: '=NUM([[PriceText]])' },
    { name: 'NUMSPLIT', syntax: '=NUMSPLIT(Parameter)', description: 'Extracts all numbers as semicolon list.', example: '=NUMSPLIT(123 Sample St, NY 10016)' },
    { name: 'PARSE', syntax: '=PARSE(GetRightOfThisText; GetLeftOfThisText; SearchWithinThisText)', description: 'Returns text between two markers. Special: crlf, tab.', example: '=PARSE(Name:; Age:; [[Data]])' },
    { name: 'PARTITION', syntax: '=PARTITION(NumberToBePartitioned; Divisor)', description: 'Returns list of integers summing to original number.', example: '=PARTITION(100; 31)' },
    { name: 'RANDOMNUM', syntax: '=RANDOMNUM(MinimumNumber; MaximumNumber)', description: 'Returns random number between bounds.', example: '=RANDOMNUM(1; 100)' },
    { name: 'REGEXFIND', syntax: '=REGEXFIND(RegEx; StringToSearch)', description: 'Returns text matching regex pattern.', example: '=REGEXFIND(\\d+; This has number: 263)' },
    { name: 'REGEXWORDSONLY', syntax: '=REGEXWORDSONLY(TextToConvertToRegex)', description: 'Converts text to regex matching words only, ignoring punctuation.', example: '=REGEXWORDSONLY([[SearchText]])' },
    { name: 'REMOVECHARS', syntax: '=REMOVECHARS(Value; CharsToRemove)', description: 'Removes specified characters from text.', example: '=REMOVECHARS([[Phone]]; -() )' },
    { name: 'REMOVEDIACRITICS', syntax: '=REMOVEDIACRITICS(Value)', description: 'Removes accents, replacing with equivalent chars.', example: '=REMOVEDIACRITICS(cafe)' },
    { name: 'REMOVESPACES', syntax: '=REMOVESPACES(Value)', description: 'Removes all spaces from text.', example: '=REMOVESPACES([[Code]])' },
    { name: 'REMOVESYMBOLS', syntax: '=REMOVESYMBOLS(Value)', description: 'Removes symbols, keeping alphanumeric and spaces.', example: '=REMOVESYMBOLS([[Input]])' },
    { name: 'REPLACE', syntax: '=REPLACE(SearchForText; NewText; SearchWithinText)', description: 'Finds and replaces text.', example: '=REPLACE(old; new; [[Text]])' },
    { name: 'RIGHT', syntax: '=RIGHT(Count; Value)', description: 'Returns specified chars from end of string.', example: '=RIGHT(4; [[Filename]])' },
    { name: 'RIGHTOF', syntax: '=RIGHTOF(ReturnRightOf; SearchInString)', description: 'Returns text right of first occurrence.', example: '=RIGHTOF(@; [[Email]])' },
    { name: 'RIGHTOFLAST', syntax: '=RIGHTOFLAST(ReturnRightOf; SearchInString)', description: 'Returns text right of LAST occurrence.', example: '=RIGHTOFLAST(/; [[FilePath]])' },
    { name: 'ROUND', syntax: '=ROUND(NumOfDecimals; AnyNumber)', description: 'Rounds to specified decimal places.', example: '=ROUND(2; [[Total]])' },
    { name: 'SPLIT', syntax: '=SPLIT(CharacterToSplitOn; IndexOfSplitToReturn; TextToSplit)', description: 'Splits on character, returns section. Index 0 returns all.', example: '=SPLIT(-; 2; [[Code]])' },
    { name: 'SUM', syntax: '=SUM(Parameter1; Parameter2; ...)', description: 'Sums list of numbers.', example: '=SUM([[Item1]]; [[Item2]]; [[Item3]])' },
    { name: 'TABLEAVG', syntax: '=TABLEAVG(FieldID; TableID; TableQuery)', description: 'Returns average of column values in table.', example: '=TABLEAVG(FieldID; TableID; Query)' },
    { name: 'TABLEJSON', syntax: '=TABLEJSON(NumberOfColumns; ProcessTableID; OptionalTableQuery)', description: 'Returns table data as JSON array of objects.', example: '=TABLEJSON(5; TableID; Query)' },
    { name: 'TABLELOOKUP', syntax: '=TABLELOOKUP(FieldTokenToRetrieve; TableID; TableQuery)', description: 'Returns value from Process Table matching query.', example: '=TABLELOOKUP([[FieldToken]]; TableID; Query)' },
    { name: 'TABLESUM', syntax: '=TABLESUM(FieldID; TableID; TableQuery)', description: 'Sums column values in table.', example: '=TABLESUM(FieldID; TableID; Query)' },
    { name: 'TASKLOOKUP', syntax: '=TASKLOOKUP(FieldTokenToRetrieve; TemplateTaskID; TaskQuery)', description: 'Queries task and returns requested attribute.', example: '=TASKLOOKUP([[AssignedTo]]; TaskID; Query)' },
    { name: 'TASKREPORT', syntax: '=TASKREPORT(TextBlockID; ProcessInstanceID; IncludeSubprocessTask; FilterQuery)', description: 'Produces task report using Text Block format. Use 0 for ProcessInstanceID to query all.', example: '=TASKREPORT([[TextBlockID]]; [[ProcessInstanceID]]; true; it_name[ct]task)' },
    { name: 'TITLECASE', syntax: '=TITLECASE(TextParameter)', description: 'Capitalizes first letter of each word.', example: '=TITLECASE([[name]])' },
    { name: 'TRIM', syntax: '=TRIM(TextToTrim)', description: 'Removes leading/trailing spaces and double spaces.', example: '=TRIM([[Input]])' },
    { name: 'UPPERCASE', syntax: '=UPPERCASE(String)', description: 'Capitalizes each letter.', example: '=UPPERCASE([[Code]])' },
    { name: 'URLENCODE', syntax: '=URLENCODE(CharacterToEncode)', description: 'Encodes characters for URL use.', example: '=URLENCODE([[SearchTerm]])' },
    { name: 'WORDSPLIT', syntax: '=WORDSPLIT(ReturnWordIndex; PlainText)', description: 'Splits text into word list. Index 0 returns all.', example: '=WORDSPLIT(1; [[FullName]])' },
    { name: 'WORKDAY', syntax: '=WORKDAY(WorkScheduleID; WorkdaysToSkip; DateToStartEvaluatingFrom)', description: 'Advances date to next working day based on work schedule.', example: '=WORKDAY([[WorkScheduleID]]; 5; [[StartDate]])' },
    { name: 'YEAR', syntax: '=YEAR(DateValue)', description: 'Extracts year from date.', example: '=YEAR([[CreatedDate]])' }
];

function renderFunctions(functions) {
    const container = document.getElementById('functionList');
    container.innerHTML = functions.map(func => `
        <div class="function-item" data-name="${func.name}">
            <div class="function-header" onclick="toggleFunction(this)">
                <span class="function-name">=${func.name}()</span>
                <span class="function-arrow">‚ñº</span>
            </div>
            <div class="function-details">
                <div class="function-syntax">${escapeHtml(func.syntax)}</div>
                <div class="function-description">${func.description}</div>
                <div class="function-example">
                    <div class="function-example-label">Example</div>
                    <div class="function-example-code">${escapeHtml(func.example)}</div>
                </div>
            </div>
        </div>
    `).join('');
}

function toggleFunction(header) {
    header.parentElement.classList.toggle('open');
}

function filterFunctions() {
    const search = document.getElementById('functionSearch').value.toLowerCase();
    const filtered = FUNCTION_DOCS.filter(func => 
        func.name.toLowerCase().includes(search)
    );
    renderFunctions(filtered);
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    loadSavedTheme();
    renderFunctions(FUNCTION_DOCS);
    renderFormulasList();
    renderFunctionStatus();
    updateEditor();
});
</script>
</body>
</html>
